# 缓存策略分析与设计

## 当前状态

- ✅ 后端：支持读取项目数据
- ✅ 前端：支持显示项目和数据
- ⏳ 后端：编辑代码、保存 .ipynb、触发执行（未实现）
- ⏳ 前端：编辑UI（未实现）

## 关键认识

编辑流程：前端编辑 → 保存到 `.ipynb` → 触发执行 → 更新缓存

这意味着：**编辑会改变后端文件和执行状态**，所以缓存必须能够被**正确地失效和更新**。

## 推荐的缓存策略：按需加载 + 编辑草稿

### 核心原则

1. **项目缓存**：存储从后端加载的项目数据（已提交版本）
2. **编辑草稿**：编辑中的代码在 Draft 中进行，不污染缓存
3. **保存流程**：编辑提交 → 后端处理 → 缓存更新
4. **缓存失效**：编辑保存成功后，更新对应的缓存数据

### 架构图

```
前端状态树
├── projectCache (已提交版本)
│   ├── test_user_behavior_analysis: ProjectDetail
│   └── test_sales_performance_report: ProjectDetail
│
├── editingDraft (编辑进行中)
│   ├── projectId
│   ├── nodeId
│   ├── code (编辑中的代码)
│   ├── isDirty (是否有未保存的改动)
│   └── isSaving (是否正在保存)
│
└── executionStatus (执行状态跟踪)
    ├── nodeId
    ├── status (pending | executing | completed | failed)
    └── result (执行结果或错误信息)
```

### 页面加载流程

```
用户进入页面
    ↓
加载第一个项目（data-analysis）
    ├─ 检查缓存
    ├─ 如果缓存存在 → 使用缓存
    └─ 如果缓存不存在 → 从后端加载 → 存入缓存
    ↓
用户切换项目
    ├─ 检查当前 Draft 是否有未保存改动
    ├─ 如果有 → 提示保存/放弃
    └─ 如果无 → 继续
    ↓
加载新项目
    ├─ 检查缓存
    ├─ 如果缓存存在 → 使用缓存
    └─ 如果缓存不存在 → 从后端加载 → 存入缓存
```

### 编辑保存流程

```
用户编辑代码
    ↓
更新 Draft 状态（不触及缓存）
    ↓
用户点击"保存"
    ↓
setEditing(isSaving = true)
    ↓
发送请求到后端：
  POST /api/projects/{projectId}/nodes/{nodeId}/save
  {
    code: "...",
    metadata: { ... }  // 如果元数据也改了
  }
    ↓
后端处理：
  1. 更新 .ipynb 文件
  2. 同步元数据注释（调用 sync_metadata_comments）
  3. 返回更新后的 Cell metadata
    ↓
保存成功
    ↓
更新缓存中对应节点的代码和元数据
    ↓
清空 Draft 状态
    ↓
setEditing(isSaving = false)
```

### 执行流程（后续实现）

```
用户编辑代码并保存
    ↓
后端返回成功 → 代码已保存到 .ipynb
    ↓
用户点击"执行节点"
    ↓
setExecutionStatus(nodeId, 'pending')
    ↓
发送请求到后端：
  POST /api/projects/{projectId}/nodes/{nodeId}/execute
    ↓
后端处理：
  1. 启动 Jupyter kernel
  2. 执行该节点代码
  3. 等待完成
  4. 返回执行结果
    ↓
执行成功
    ↓
setExecutionStatus(nodeId, 'completed')
    ↓
更新缓存中该节点的：
  - execution_status: 'validated'
  - result_path: '...'
  - result_data: { ... }
    ↓
刷新 DataTable 显示新结果
```

## 缓存管理的关键点

### 何时加载
- ✅ 页面初始化时加载第一个项目
- ✅ 用户切换项目时加载（缓存存在则使用缓存）
- ❌ 页面刷新时加载第一个项目
- ❌ 反复加载已缓存的项目

### 何时更新缓存
- 编辑保存成功后
- 执行成功后
- 用户主动刷新项目

### 何时清空缓存
- 用户登出（如有认证）
- 应用版本升级（可选，看是否有 schema 变化）
- 不自动清空（避免丢失数据）

### 何时提示警告
- 用户有未保存的编辑，尝试切换项目
- 用户有未保存的编辑，尝试刷新页面
- 用户有正在执行的节点，尝试离开

## 实现优先级

1. **第一阶段**（当前）：
   - ✅ 按需加载项目（已缓存不重新加载）
   - ✅ 第一次进入加载第一个项目
   - 📝 简化缓存逻辑（仅缓存项目元数据和节点列表）

2. **第二阶段**（实现编辑功能时）：
   - 编辑 Draft 状态管理
   - 代码保存 API
   - 元数据自动同步
   - 缓存更新逻辑

3. **第三阶段**（实现执行功能时）：
   - 执行状态跟踪
   - 执行结果加载
   - 执行后缓存更新
   - 进度显示

## 不需要做的事

- ❌ 实时同步（只在保存时同步）
- ❌ 多用户冲突处理（假设单用户）
- ❌ 版本历史（除非特别需要）
- ❌ 乐观更新（编辑保存需要等待确认）
