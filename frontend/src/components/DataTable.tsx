import React, { useState, useEffect, useRef } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { ChevronLeft, ChevronRight, Code, FileText, X, Play, AlertCircle, Loader2, Trash2 } from "lucide-react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from "@/components/ui/resizable";
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  ScatterChart,
  Scatter,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  Cell,
} from "recharts";
import SyntaxHighlighter from "react-syntax-highlighter";
import { atomOneDark } from "react-syntax-highlighter/dist/esm/styles/hljs";
import ReactMarkdown from "react-markdown";
import Editor from "react-simple-code-editor";
import { highlight, languages } from "prismjs";
import "prismjs/components/prism-python";
import "prismjs/themes/prism-tomorrow.css";
import remarkGfm from "remark-gfm";
import { getNodeData, getNodeCode, getNodeMarkdown, updateNodeMarkdown, updateNodeCode, executeNode, getFileUrl, getProject, getDictResult, type PaginatedData } from "@/services/api";
import { useProjectCache } from "@/hooks/useProjectCache";
import { useUnsavedChanges } from "@/hooks/useUnsavedChanges";
import { UnsavedChangesDialog } from "@/components/UnsavedChangesDialog";
import { useToast } from "@/hooks/use-toast";
import { shouldLoadResultData, getDefaultPanel, shouldShowCodePanel } from "@/config/displayRegistry";
import { DictResultDisplay } from "@/components/displays/DictResultDisplay";

interface DataRow {
  [key: string]: string | number;
}

interface DataTableProps {
  selectedNodeId: string | null;
  onNodeDeselect?: () => void;
  currentDatasetId?: string;
  onProjectUpdate?: () => void;
  onNodeDelete?: (nodeId: string) => void;
}

/**
 * Strip metadata comments from code
 *
 * Removes system-generated metadata comments that look like:
 * # ===== System-managed metadata (auto-generated, understand to edit) =====
 * # @node_type: compute
 * # @node_id: report
 * # ...
 * # ===== End of system-managed metadata =====
 *
 * Only removes comment lines within metadata block, preserves all empty lines.
 */
function stripMetadataComments(code: string): string {
  const lines = code.split('\n');
  let result: string[] = [];
  let inMetadataBlock = false;

  for (const line of lines) {
    // Check if entering metadata block
    if (line.includes('System-managed metadata')) {
      inMetadataBlock = true;
      continue;
    }
    // Check if exiting metadata block
    if (line.includes('End of system-managed metadata')) {
      inMetadataBlock = false;
      continue;
    }
    // Skip lines inside metadata block
    if (inMetadataBlock) {
      continue;
    }
    // Keep all other lines (including empty lines)
    result.push(line);
  }

  return result.join('\n');
}

/**
 * Syntax-highlighted code editor component
 * Uses react-simple-code-editor with prismjs for integrated highlighting
 * No layering issues - single unified editor with built-in syntax highlighting
 */
interface CodeEditorProps {
  value: string;
  onChange: (value: string) => void;
  language?: string;
}

function CodeEditor({ value, onChange, language = 'python' }: CodeEditorProps) {
  return (
    <div className="w-full h-full flex-1 overflow-hidden" style={{ backgroundColor: '#282c34' }}>
      <style>{`
        .editor-container {
          font-family: 'Fira Code', 'Courier New', monospace;
          font-size: 12px;
          line-height: 1.5;
        }
        .editor-container textarea {
          background-color: transparent !important;
          color: #abb2bf !important;
          caret-color: #61afef !important;
          outline: none !important;
          border: none !important;
        }
        .editor-container pre {
          background-color: #282c34 !important;
          color: #abb2bf !important;
        }
        .token.punctuation { color: #abb2bf; }
        .token.keyword { color: #c678dd; }
        .token.string { color: #98c379; }
        .token.function { color: #61afef; }
        .token.number { color: #d19a66; }
        .token.comment { color: #5c6370; font-style: italic; }
        .token.operator { color: #abb2bf; }
      `}</style>
      {/* @ts-ignore */}
      <Editor
        value={value}
        onValueChange={onChange}
        highlight={(code) => highlight(code, languages.python, 'python')}
        padding={12}
        style={{
          fontFamily: 'inherit',
          fontSize: '12px',
          lineHeight: '1.5',
          width: '100%',
          height: '100%',
          backgroundColor: '#282c34',
          color: '#abb2bf',
        }}
        className="editor-container"
        textareaClassName="editor-textarea"
        preClassName="editor-pre"
      />
    </div>
  );
}

// 贷款风控分析场景的节点数据
const nodeDataMap: Record<string, {
  title: string;
  headers: string[];
  data: DataRow[];
  totalRecords: number;
  type?: 'table' | 'chart';
  code?: string;
  conclusion?: string;
  chartType?: string; // 'scatter' | 'line' | 'bar'
  result_format?: string;
}> = {
  // ===== 数据源节点（蓝色） =====
  'data-1': {
    title: '用户基本信息数据',
    headers: ['用户ID', '姓名', '年龄', '性别', '职业', '月收入'],
    data: [
      { '用户ID': 'U001', '姓名': '王某', '年龄': 32, '性别': '男', '职业': '软件工程师', '月收入': 18000 },
      { '用户ID': 'U002', '姓名': '李某', '年龄': 28, '性别': '女', '职业': '销售经理', '月收入': 12000 },
      { '用户ID': 'U003', '姓名': '张某', '年龄': 45, '性别': '男', '职业': '企业主', '月收入': 35000 },
      { '用户ID': 'U004', '姓名': '陈某', '年龄': 29, '性别': '女', '职业': '医生', '月收入': 22000 },
      { '用户ID': 'U005', '姓名': '黄某', '年龄': 35, '性别': '男', '职业': '公务员', '月收入': 15000 },
    ],
    totalRecords: 285000,
    type: 'table',
    code: `SELECT
  用户ID,
  姓名,
  年龄,
  性别,
  职业,
  月收入
FROM 用户基本信息表
WHERE 状态 = '有效'
LIMIT 5;`,
    conclusion: `# 用户基本信息数据

## 数据规模
- **总记录数**：285,000 条
- **数据周期**：2023-2024年
- **更新频率**：月度

## 字段结构（6个字段）

| 字段名 | 数据类型 | 说明 | 取值范围 |
|-------|--------|------|--------|
| 用户ID | String | 用户唯一标识 | U000001 - U285000 |
| 姓名 | String | 用户姓名 | 中文名字 |
| 年龄 | Integer | 用户年龄 | 18-75岁 |
| 性别 | String | 用户性别 | 男/女 |
| 职业 | String | 用户职业类型 | 多个职业分类 |
| 月收入 | Integer | 月收入（元） | 8,000-50,000元 |

## 数据质量指标
- **完整性**：98%（缺失值 < 2%）
- **去重率**：100%（无重复记录）
- **时间覆盖**：连续月度数据

## 数据来源
- 来源系统：用户管理系统
- 数据表：user_profile
- 导出日期：2024-01-01

## 后续使用
- 作为 compute-1 的输入（用户特征分析）
- 作为 compute-6 的输入（首贷vs复贷对比）
- 支撑客户标签体系建立`,
  },

  'data-2': {
    title: '贷款申请数据',
    headers: ['申请ID', '用户ID', '申请日期', '申请金额(万)', '期限(月)', '用途'],
    data: [
      { '申请ID': 'L001', '用户ID': 'U001', '申请日期': '2024-01-15', '申请金额(万)': 30, '期限(月)': 12, '用途': '购车' },
      { '申请ID': 'L002', '用户ID': 'U002', '申请日期': '2024-01-16', '申请金额(万)': 15, '期限(月)': 24, '用途': '装修' },
      { '申请ID': 'L003', '用户ID': 'U003', '申请日期': '2024-01-17', '申请金额(万)': 50, '期限(月)': 36, '用途': '经营' },
      { '申请ID': 'L004', '用户ID': 'U004', '申请日期': '2024-01-18', '申请金额(万)': 20, '期限(月)': 12, '用途': '教育' },
      { '申请ID': 'L005', '用户ID': 'U005', '申请日期': '2024-01-19', '申请金额(万)': 25, '期限(月)': 24, '用途': '购车' },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  申请ID,
  用户ID,
  申请日期,
  申请金额,
  期限,
  用途
FROM 贷款申请表
WHERE 申请日期 >= '2024-01-01'
ORDER BY 申请日期 DESC
LIMIT 5;`,
    conclusion: `# 贷款申请数据

## 数据规模
- **总记录数**：143,000 条
- **数据周期**：2024年全年
- **更新频率**：日度（每日新增申请）

## 字段结构（6个字段）

| 字段名 | 数据类型 | 说明 | 取值范围 |
|-------|--------|------|--------|
| 申请ID | String | 申请唯一标识 | L000001 - L143000 |
| 用户ID | String | 关联用户ID | U000001 - U285000 |
| 申请日期 | Date | 贷款申请日期 | 2024-01-01 至今 |
| 申请金额(万) | Integer | 申请贷款金额 | 10-100万 |
| 期限(月) | Integer | 还款期限 | 3-60个月 |
| 用途 | String | 贷款用途 | 购车/装修/经营/教育 |

## 数据质量指标
- **完整性**：99%（缺失值 < 1%）
- **去重率**：100%（无重复申请）
- **时间覆盖**：连续日度数据

## 数据来源
- 来源系统：贷款审批系统
- 数据表：loan_application
- 导出日期：2024-01-01

## 后续使用
- 作为 compute-1 的输入（申请人特征分析）
- 作为 compute-2 的输入（年龄-收入交叉分析）
- 作为 compute-3 的输入（职业风险分析）
- 作为 compute-4 的输入（逾期率统计）
- 作为 compute-5 的输入（金额与违约关系）
- 作为 compute-6 的输入（首贷vs复贷对比）`,
  },

  'data-3': {
    title: '还款历史数据',
    headers: ['用户ID', '已还期数', '应还期数', '逾期次数', '逾期天数', '风险标签'],
    data: [
      { '用户ID': 'U001', '已还期数': 8, '应还期数': 12, '逾期次数': 0, '逾期天数': 0, '风险标签': '正常' },
      { '用户ID': 'U002', '已还期数': 12, '应还期数': 24, '逾期次数': 1, '逾期天数': 5, '风险标签': '轻微逾期' },
      { '用户ID': 'U003', '已还期数': 18, '应还期数': 36, '逾期次数': 0, '逾期天数': 0, '风险标签': '正常' },
      { '用户ID': 'U004', '已还期数': 5, '应还期数': 12, '逾期次数': 2, '逾期天数': 25, '风险标签': '严重逾期' },
      { '用户ID': 'U005', '已还期数': 10, '应还期数': 24, '逾期次数': 0, '逾期天数': 0, '风险标签': '正常' },
    ],
    totalRecords: 285000,
    type: 'table',
    code: `SELECT
  用户ID,
  已还期数,
  应还期数,
  逾期次数,
  SUM(逾期天数) as 总逾期天数,
  CASE
    WHEN 逾期次数 = 0 THEN '正常'
    WHEN 逾期次数 = 1 THEN '轻微逾期'
    ELSE '严重逾期'
  END as 风险标签
FROM 还款历史表
GROUP BY 用户ID
LIMIT 5;`,
    conclusion: `# 还款历史数据

## 数据规模
- **总记录数**：285,000 条
- **数据周期**：2023-2024年（历史贷款）
- **更新频率**：月度（月底结算）

## 字段结构（6个字段）

| 字段名 | 数据类型 | 说明 | 取值范围 |
|-------|--------|------|--------|
| 用户ID | String | 用户唯一标识 | U000001 - U285000 |
| 已还期数 | Integer | 已偿还期数 | 0-60 |
| 应还期数 | Integer | 应偿还总期数 | 3-60 |
| 逾期次数 | Integer | 逾期次数统计 | 0-20 |
| 逾期天数 | Integer | 逾期天数累计 | 0-1000 |
| 风险标签 | String | 还款风险分类 | 正常/轻微逾期/严重逾期 |

## 数据质量指标
- **完整性**：99%（缺失值 < 1%）
- **去重率**：100%（按用户ID去重）
- **时间覆盖**：连续月度数据

## 数据来源
- 来源系统：贷款管理系统
- 数据表：repayment_history
- 导出日期：2024-01-01

## 后续使用
- 作为 compute-4 的输入（逾期率统计）
- 作为 compute-5 的输入（金额与违约关系）
- 作为 compute-6 的输入（首贷vs复贷对比）`,
  },

  // ===== 阶段2：初步探索 - 分支A（申请端分析） =====
  'explore-a1': {
    title: '申请人特征分布统计',
    headers: ['特征维度', '值1', '占比1(%)', '值2', '占比2(%)', '平均值'],
    data: [
      { '特征维度': '年龄段', '值1': '25-30岁', '占比1(%)': 28, '值2': '31-40岁', '占比2(%)': 45, '平均值': '34.5岁' },
      { '特征维度': '月收入', '值1': '10-15k', '占比1(%)': 32, '值2': '15-25k', '占比2(%)': 48, '平均值': '18.2k' },
      { '特征维度': '职业类型', '值1': '企业员工', '占比1(%)': 45, '值2': '个体商户', '占比2(%)': 20, '平均值': '-' },
      { '特征维度': '申请金额', '值1': '10-30w', '占比1(%)': 65, '值2': '30-50w', '占比2(%)': 25, '平均值': '24w' },
      { '特征维度': '婚姻状况', '值1': '已婚', '占比1(%)': 62, '值2': '未婚', '占比2(%)': 38, '平均值': '-' },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  年龄段,
  COUNT(*) as 申请数,
  COUNT(*) * 100.0 / SUM(COUNT(*)) OVER() as 占比,
  AVG(申请金额) as 平均金额,
  CORR(年龄, 违约) as 与违约的相关系数
FROM 贷款申请表
GROUP BY 年龄段
ORDER BY 申请数 DESC;`,
    conclusion: `# 申请人特征分布分析

## 发现1：年龄段分化明显
- **31-40岁**是申请主力（45%）
- **25-30岁**次之（28%）
- 高龄申请者（>50岁）占比仅5%
- **结论**：中年人群更有贷款需求

## 发现2：收入水平分化
- **15k-25k**是主流（48%）
- **10k-15k**次之（32%）
- 高收入者（>35k）占比18%
- **结论**：中等收入人群是主要客户

## 发现3：职业风险差异
- 企业员工（风险较低）
- 个体商户（风险中等）
- 自由职业（风险较高）
- **结论**：需要按职业差异化定价

## 发现4：申请额度集中
- 10-30万是主流（65%）
- 这个额度范围违约率相对可控
- **结论**：超大额贷款需谨慎

## 下一步建议
- 需要看申请人这些特征与违约率的关系
- 不同组合的特征风险差异大吗？`,
  },

  'explore-a2': {
    title: '年龄-收入散点分析',
    headers: ['年龄段', '低收入(8-12k)', '中等收入(12-20k)', '高收入(20k+)', '平均违约率(%)'],
    data: [
      { '年龄段': '25-30岁', '低收入(8-12k)': 85, '中等收入(12-20k)': 120, '高收入(20k+)': 45, '平均违约率(%)': 24 },
      { '年龄段': '31-40岁', '低收入(8-12k)': 120, '中等收入(12-20k)': 380, '高收入(20k+)': 180, '平均违约率(%)': 18 },
      { '年龄段': '41-50岁', '低收入(8-12k)': 60, '中等收入(12-20k)': 150, '高收入(20k+)': 140, '平均违约率(%)': 15 },
      { '年龄段': '50岁以上', '低收入(8-12k)': 25, '中等收入(12-20k)': 50, '高收入(20k+)': 60, '平均违约率(%)': 22 },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  年龄段,
  收入段,
  COUNT(*) as 申请数,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 违约率
FROM 贷款申请表
GROUP BY 年龄段, 收入段
ORDER BY 年龄段, 收入段;`,
    conclusion: `# 年龄-收入散点图分析

## 关键发现！

### 发现1：年轻低收入风险高
- **25-30岁+低收入**：违约率24%
- 年轻人群借贷需求强但收入不稳定
- 这个组合值得重点关注

### 发现2：中年中等收入最安全
- **31-40岁+中等收入**：违约率18%
- 这是最大的客户群体（380人）
- 也是最稳定的群体

### 发现3：高收入相对安全
- 跨所有年龄段，高收入组的违约率都较低
- 高收入成为强保护因素

### 发现4：年龄越大越稳定
- 41-50岁违约率最低（15%）
- 说明年龄与还款稳定性正相关

## 风险分组
- **高风险**：年轻（<30）+低收入
- **中风险**：中年+中等收入
- **低风险**：40+岁或高收入

## 重要结论
**这个图表很关键！说明我们需要按年龄-收入组合来评估风险，不能只看单一维度。**`,
  },

  'explore-a3': {
    title: '职业申请数量与违约率统计',
    headers: ['职业类型', '申请数', '占比(%)', '违约人数', '违约率(%)', '平均申请额(万)'],
    data: [
      { '职业类型': '软件/IT工程师', '申请数': 18500, '占比(%)': 13.0, '违约人数': 2590, '违约率(%)': 14, '平均申请额(万)': 28 },
      { '职业类型': '销售/市场类', '申请数': 22300, '占比(%)': 15.6, '违约人数': 4228, '违约率(%)': 19, '平均申请额(万)': 22 },
      { '职业类型': '个体/商户', '申请数': 28600, '占比(%)': 20.0, '违约人数': 8008, '违约率(%)': 28, '平均申请额(万)': 35 },
      { '职业类型': '医疗/教育工作者', '申请数': 16200, '占比(%)': 11.3, '违约人数': 1458, '违约率(%)': 9, '平均申请额(万)': 20 },
      { '职业类型': '公务员/事业单位', '申请数': 14800, '占比(%)': 10.4, '违约人数': 1480, '违约率(%)': 10, '平均申请额(万)': 18 },
      { '职业类型': '其他工作者', '申请数': 42600, '占比(%)': 29.8, '违约人数': 12348, '违约率(%)': 29, '平均申请额(万)': 24 },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  职业类型,
  COUNT(*) as 申请数,
  COUNT(*) * 100.0 / SUM(COUNT(*)) OVER() as 占比,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) as 违约人数,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 违约率,
  AVG(申请金额) as 平均申请额
FROM 贷款申请表
GROUP BY 职业类型
ORDER BY 申请数 DESC;`,
    conclusion: `# 职业类型分析 - 发现重要风险信号！

## 关键发现！！

### 高风险职业群体
- **个体/商户**：违约率28%（申请数最多：20%）
- **其他工作者**：违约率29%（占比最大：30%）
- 这两类合起来占申请总数的50%，但都是高风险

### 中等风险职业
- **销售/市场类**：违约率19%
- 申请额度较低，但风险不低

### 低风险职业群体
- **医疗/教育工作者**：违约率9%（最低！）
- **公务员/事业单位**：违约率10%
- 这两类虽然申请数较少，但非常稳定
- 应该优先审批这些职业

### 申请额度与职业的关系
- 个体商户申请额度最高（35万）
- 这加剧了风险（大额+高风险职业）

## 重要洞察
**职业是最强的风险预测器！**
- 同样是申请30万，个体商户（28%违约）vs医生（9%违约）
- 风险相差3倍！

## 分支A阶段结论
我们发现了关键的风险维度：
1. 年龄-收入组合很重要
2. 职业是最强风险因子
3. 需要结合还款数据看是否确实如此`,
  },

  // ===== 阶段2：初步探索 - 分支B（还款端分析） =====
  'explore-b1': {
    title: '逾期率分布统计',
    headers: ['时间段', '贷款总数', '逾期笔数', '逾期率(%)', '平均逾期天数', '严重逾期比(%)'],
    data: [
      { '时间段': '2023年Q1(1-3月申请)', '贷款总数': 31500, '逾期笔数': 6300, '逾期率(%)': 20, '平均逾期天数': 18, '严重逾期比(%)': 8 },
      { '时间段': '2023年Q2(4-6月申请)', '贷款总数': 28800, '逾期笔数': 5040, '逾期率(%)': 17.5, '平均逾期天数': 15, '严重逾期比(%)': 6 },
      { '时间段': '2023年Q3(7-9月申请)', '贷款总数': 35200, '逾期笔数': 9240, '逾期率(%)': 26.3, '平均逾期天数': 22, '严重逾期比(%)': 11 },
      { '时间段': '2023年Q4(10-12月申请)', '贷款总数': 42000, '逾期笔数': 8820, '逾期率(%)': 21, '平均逾期天数': 16, '严重逾期比(%)': 7 },
      { '时间段': '2024年Q1(1月申请)', '贷款总数': 5500, '逾期笔数': 1650, '逾期率(%)': 30, '平均逾期天数': 25, '严重逾期比(%)': 14 },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  TO_CHAR(申请日期, 'YYYY Q') as 时间段,
  COUNT(*) as 贷款总数,
  SUM(CASE WHEN 逾期次数 > 0 THEN 1 ELSE 0 END) as 逾期笔数,
  SUM(CASE WHEN 逾期次数 > 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 逾期率,
  AVG(CASE WHEN 逾期次数 > 0 THEN 逾期天数 ELSE NULL END) as 平均逾期天数
FROM 贷款表
GROUP BY TO_CHAR(申请日期, 'YYYY Q')
ORDER BY 时间段;`,
    conclusion: `# 逾期率分布分析 - 发现时间规律！

## 关键发现！！

### 时间趋势分析
- **2023年Q1**：20% 逾期率（基础水平）
- **2023年Q2**：17.5% 逾期率（改善）
- **2023年Q3**：26.3% 逾期率（恶化！）
- **2023年Q4**：21% 逾期率（反弹）
- **2024年Q1**：30% 逾期率（急速恶化！！）

### 关键信号
- **Q3明显异常**（26.3%）
  - 可能是经济因素（3季度就业压力）？
  - 还是9月份审批标准放松？

- **2024年Q1最危险**（30%）
  - 最近审批的贷款风险最高！
  - 说明近期风控可能出现问题

### 严重逾期趋势
- Q3和2024Q1的严重逾期比最高（11%和14%）
- 这不仅是逾期增加，而是逾期在恶化

## 重要结论
**不同时期申请的贷款风险不同！**
- 最近申请的贷款风险最高（30%）
- 需要立即查看最近的审批流程是否出现问题
- 可能需要紧急加强最近期的风控`,
  },

  'explore-b2': {
    title: '逾期率时间序列趋势',
    headers: ['申请月份', '贷款数', '逾期率(%)', '环比变化', '可能原因/标注'],
    data: [
      { '申请月份': '2023年9月', '贷款数': 11200, '逾期率(%)': 26.3, '环比变化': '+8.8%', '可能原因/标注': '经济压力/季节性' },
      { '申请月份': '2023年10月', '贷款数': 14000, '逾期率(%)': 20.5, '环比变化': '-5.8%', '可能原因/标注': '反弹回稳' },
      { '申请月份': '2023年11月', '贷款数': 14500, '逾期率(%)': 21.8, '环比变化': '+1.3%', '可能原因/标注': '稳定' },
      { '申请月份': '2023年12月', '贷款数': 13500, '逾期率(%)': 21.2, '环比变化': '-0.6%', '可能原因/标注': '年底冲刺期' },
      { '申请月份': '2024年1月', '贷款数': 5500, '逾期率(%)': 30, '环比变化': '+8.8%', '可能原因/标注': '!!急速恶化！' },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  DATE_TRUNC('month', 申请日期) as 申请月份,
  COUNT(*) as 贷款数,
  SUM(CASE WHEN 逾期次数 > 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 逾期率,
  LAG(SUM(CASE WHEN 逾期次数 > 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*))
    OVER (ORDER BY DATE_TRUNC('month', 申请日期)) as 前月逾期率
FROM 贷款表
WHERE 申请日期 >= '2023-09-01'
GROUP BY DATE_TRUNC('month', 申请日期)
ORDER BY 申请月份;`,
    conclusion: `# 逾期率时间序列趋势分析

## 危急信号！！

### 第一个异常期：2023年9月
- 逾期率飙升到26.3%
- 环比上升+8.8个百分点
- 可能原因：
  - 经济下行预期
  - 就业市场波动
  - 还是审批标准改变？

### 第二个异常期：2024年1月（最危险！）
- 逾期率高达30%！
- 环比上升+8.8个百分点（与9月相同幅度！）
- **这是关键问题：连续出现两次大幅恶化**

### 可能的解释
1. **风控标准放松**
   - 最近批准了太多风险用户？
   - 需要检查1月的审批数据

2. **某个特定群体问题**
   - 某个职业的用户大量违约？
   - 某个地域的用户问题？
   - 某个贷款用途的问题？

3. **市场环境恶化**
   - 1月份经济确实有压力
   - 但需要与历年对比

## 立即行动建议
**需要进入分支D（特殊人群分析）**
- 看最近申请的用户有什么特殊之处
- 是新审批策略导致的吗？
- 需要第一时间介入`,
  },

  'explore-b3': {
    title: '申请金额与违约率交叉分析',
    headers: ['金额区间(万)', '申请笔数', '占比(%)', '逾期笔数', '逾期率(%)', '平均期限(月)'],
    data: [
      { '金额区间(万)': '10-15', '申请笔数': 42900, '占比(%)': 30, '逾期笔数': 6006, '逾期率(%)': 14, '平均期限(月)': 18 },
      { '金额区间(万)': '15-25', '申请笔数': 50050, '占比(%)': 35, '逾期笔数': 8508, '逾期率(%)': 17, '平均期限(月)': 22 },
      { '金额区间(万)': '25-35', '申请笔数': 32200, '占比(%)': 22.5, '逾期笔数': 7408, '逾期率(%)': 23, '平均期限(月)': 26 },
      { '金额区间(万)': '35-50', '申请笔数': 14300, '占比(%)': 10, '逾期笔数': 3861, '逾期率(%)': 27, '平均期限(月)': 30 },
      { '金额区间(万)': '50以上', '申请笔数': 3550, '占比(%)': 2.5, '逾期笔数': 1347, '逾期率(%)': 38, '平均期限(月)': 33 },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  申请金额区间,
  COUNT(*) as 申请笔数,
  SUM(CASE WHEN 逾期次数 > 0 THEN 1 ELSE 0 END) as 逾期笔数,
  SUM(CASE WHEN 逾期次数 > 0 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 逾期率,
  AVG(期限) as 平均期限
FROM 贷款表
GROUP BY 申请金额区间
ORDER BY 申请金额 ASC;`,
    conclusion: `# 申请金额与违约率关系分析 - 发现强相关性！

## 核心发现：金额越大，违约率越高！

### 违约率与金额的强正相关
- **10-15万**：14% 违约率（最安全）
- **15-25万**：17% 违约率
- **25-35万**：23% 违约率
- **35-50万**：27% 违约率
- **50万以上**：38% 违约率（最危险！）

### 关键数据
- 从10-15万到50万+，违约率翻了2.7倍！
- 大额贷款（50万+）虽然只占2.5%，但违约率最高
- 这些大额贷款是风险炸弹

### 期限的影响
- 更大的金额对应更长的期限
- 期限越长，违约的概率越高（时间更长，变数更多）
- 50万+ 平均期限33个月，违约率38%

## 重要结论
**金额是第二强的风险预测器**（仅次于职业）

## 分支B阶段结论
还款端数据揭示：
1. **时间很关键**：最近的贷款风险大幅上升
2. **金额很关键**：大额贷款风险指数级增加
3. **需要找原因**：为什么最近的大额贷款风险这么高？
   - 是金额大的人更多违约？
   - 还是最近审批的人中金额大的占比高？`,
  },

  // ===== 阶段3：联合分析 - 分支C（风险模型） =====
  'analyze-c1': {
    title: '交叉特征与违约相关性分析',
    headers: ['特征组合', '样本数', '违约人数', '违约率(%)', '相关系数', '风险等级'],
    data: [
      { '特征组合': '年轻(<30) + 低收入(<12k) + 个体户 + 大额(>30w)', '样本数': 980, '违约人数': 353, '违约率(%)': 36, '相关系数': 0.72, '风险等级': '超高风险' },
      { '特征组合': '中年(30-40) + 中收入(12-20k) + 企业员工 + 中额(20-30w)', '样本数': 18500, '违约人数': 2590, '违约率(%)': 14, '相关系数': -0.45, '风险等级': '低风险' },
      { '特征组合': '35-45岁 + 高收入(>20k) + 医生/教师 + 任意金额', '样本数': 8200, '违约人数': 492, '违约率(%)': 6, '相关系数': -0.68, '风险等级': '极低风险' },
      { '特征组合': '任何年龄 + 任何收入 + 个体户 + 大额(>30w) + 2024年1月申请', '样本数': 2100, '违约人数': 861, '违约率(%)': 41, '相关系数': 0.81, '风险等级': '致命风险' },
      { '特征组合': '中年(30-45) + 中等收入 + 公务员/事业单位 + 小额(<20w)', '样本数': 12000, '违约人数': 600, '违约率(%)': 5, '相关系数': -0.72, '风险等级': '极低风险' },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  年龄段 || '|' || 收入段 || '|' || 职业 || '|' || 金额段 as 特征组合,
  COUNT(*) as 样本数,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) as 违约人数,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 违约率,
  CORR(多特征向量, 是否违约) as 相关系数
FROM 贷款表
GROUP BY 年龄段, 收入段, 职业, 金额段
HAVING COUNT(*) > 100
ORDER BY 违约率 DESC
LIMIT 10;`,
    conclusion: `# 交叉特征与违约相关性分析 - 发现致命组合！

## 最危险的组合：致命风险（违约率41%）
年轻 + 低收入 + 个体户 + 大额 + 最近申请
- 这个组合违约率是平均水平的2倍！
- 相关系数0.81（非常强的正相关）
- 样本数2100人，这不是小数目

## 次危险的组合：超高风险（违约率36%）
年轻(<30) + 低收入 + 个体户 + 大额
- 基础风险组合，没有时间因素
- 但已经很危险

## 最安全的组合：极低风险（违约率5-6%）
高收入或公务员/医生/教师身份
- 即使申请大额贷款，也很安全
- 职业和收入非常重要

## 模型开发洞察
这些组合可以直接用于风险评分模型：
- 超高风险（>30%）：直接拒绝
- 高风险（20-30%）：需特殊审查
- 中等风险（15-20%）：标准流程
- 低风险（<15%）：快速审批

## 分支C的关键发现
1. **多个特征需要组合看**，不能单独看
2. **时间因素很重要**，2024年1月的申请明显风险高
3. **某些组合是"致命"的**，需要在审批流程中拦截`,
  },

  'analyze-c2': {
    title: '特征重要性排序',
    headers: ['排序', '特征名称', '重要性分数(0-1)', '与违约的相关系数', '在风控模型中的作用'],
    data: [
      { '排序': '1', '特征名称': '职业类型', '重要性分数(0-1)': 0.92, '与违约的相关系数': 0.78, '在风控模型中的作用': '最强预测器' },
      { '排序': '2', '特征名称': '申请金额', '重要性分数(0-1)': 0.88, '与违约的相关系数': 0.73, '在风控模型中的作用': '第二强预测器' },
      { '排序': '3', '特征名称': '申请月份/时间', '重要性分数(0-1)': 0.76, '与违约的相关系数': 0.62, '在风控模型中的作用': '重要环境因子' },
      { '排序': '4', '特征名称': '年龄', '重要性分数(0-1)': 0.68, '与违约的相关系数': -0.55, '在风控模型中的作用': '缓冲因素' },
      { '排序': '5', '特征名称': '月收入', '重要性分数(0-1)': 0.72, '与违约的相关系数': -0.61, '在风控模型中的作用': '保护因素' },
      { '排序': '6', '特征名称': '贷款期限', '重要性分数(0-1)': 0.65, '与违约的相关系数': 0.58, '在风控模型中的作用': '次要风险因子' },
      { '排序': '7', '特征名称': '婚姻状况', '重要性分数(0-1)': 0.42, '与违约的相关系数': -0.35, '在风控模型中的作用': '弱保护因素' },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `-- 特征重要性计算（基于信息增益）
WITH feature_importance AS (
  SELECT
    '职业类型' as 特征,
    information_gain(职业, 是否违约) as 重要性,
    correlation(职业_encoded, 是否违约) as 相关系数
  FROM 贷款表
  UNION ALL
  SELECT '申请金额', information_gain(申请金额, 是否违约),
         correlation(申请金额, 是否违约)
  -- ... 其他特征
)
SELECT * FROM feature_importance
ORDER BY 重要性 DESC;`,
    conclusion: `# 特征重要性排序 - 揭示最强风险预测器！

## 排序结果分析

### Top 3 最重要的特征

**第1名：职业类型（0.92）**
- 与违约的相关系数：0.78（最强）
- 是我们最强的预测器
- 不同职业的违约率差异巨大（9%-29%）
- **建议**：职业应该是审批规则的第一关键因子

**第2名：申请金额（0.88）**
- 与违约的相关系数：0.73
- 金额与违约率呈明显正相关
- 50万+的违约率是10-15万的2.7倍
- **建议**：需要设置审慎的额度上限

**第3名：申请时间/月份（0.76）**
- 与违约的相关系数：0.62
- 最近申请的贷款风险上升
- 2024年1月出现异常
- **建议**：需要定期重新评估风险水位，动态调整审批标准

### 保护性因素

**收入（0.72，负相关-0.61）**
- 高收入是强保护因素

**年龄（0.68，负相关-0.55）**
- 年纪大（40+）相对安全

## 模型构建建议
优先使用Top 3特征构建基础模型：
- 风险评分 = 职业权重 * 0.4 + 金额权重 * 0.35 + 时间权重 * 0.25

## 分支C总结
我们找到了可用的风险评分框架！
- 职业最重要
- 金额次之
- 还要动态考虑时间因素`,
  },

  // ===== 阶段3：联合分析 - 分支D（特殊人群） =====
  'analyze-d1': {
    title: '首贷vs复贷违约率对比',
    headers: ['客户类型', '样本数', '占比(%)', '违约人数', '违约率(%)', '平均申请额(万)', '平均期限(月)'],
    data: [
      { '客户类型': '首次借贷者(首贷)', '样本数': 89500, '占比(%)': 62.6, '违约人数': 19686, '违约率(%)': 22, '平均申请额(万)': 22, '平均期限(月)': 21 },
      { '客户类型': '复贷客户(2次)', '样本数': 35500, '占比(%)': 24.8, '违约人数': 5325, '违约率(%)': 15, '平均申请额(万)': 26, '平均期限(月)': 24 },
      { '客户类型': '多次借贷者(3次+)', '样本数': 18000, '占比(%)': 12.6, '违约人数': 1620, '违约率(%)': 9, '平均申请额(万)': 28, '平均期限(月)': 26 },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  CASE
    WHEN 贷款次数 = 1 THEN '首次借贷'
    WHEN 贷款次数 = 2 THEN '复贷'
    ELSE '多次借贷(3+)'
  END as 客户类型,
  COUNT(*) as 样本数,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) as 违约人数,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 违约率,
  AVG(申请金额) as 平均申请额,
  AVG(期限) as 平均期限
FROM 贷款表
GROUP BY
  CASE
    WHEN 贷款次数 = 1 THEN '首次借贷'
    WHEN 贷款次数 = 2 THEN '复贷'
    ELSE '多次借贷(3+)'
  END;`,
    conclusion: `# 首贷vs复贷违约率对比分析

## 关键发现：有借贷历史的客户风险更低！

### 违约率对比
- **首次借贷**：22% 违约率（最高）
- **复贷（2次）**：15% 违约率（改善）
- **多次借贷（3次+）**：9% 违约率（最低）

### 关键洞察
- 有成功还款历史的客户更可靠
- 每多一次成功的借贷，违约风险大幅下降
- 多次借贷的客户虽然申请额度更大（28万），但违约率反而最低（9%）

## 业务启示
- **首贷客户**需要更严格的审批
- **复贷客户**可以从宽考虑
- **多次借贷客户**是优质客户，应该优先支持

## 分支D的发现
这为我们的风险评估增加了新维度：
**借贷历史是判断客户是否可靠的重要指标**`,
  },

  'analyze-d2': {
    title: '黑名单客户复申情况分析',
    headers: ['风险标签', '曾经违约/拒绝', '复申人数', '复申成功率(%)', '再次违约率(%)', '建议'],
    data: [
      { '风险标签': '历史严重逾期(90天+)', '曾经违约/拒绝': 4200, '复申人数': 1680, '复申成功率(%)': 40, '再次违约率(%)': 68, '建议': '谨慎审批' },
      { '风险标签': '历史逾期3-5次', '曾经违约/拒绝': 6800, '复申人数': 2040, '复申成功率(%)': 30, '再次违约率(%)': 55, '建议': '从严审批' },
      { '风险标签': '曾被拒贷', '曾经违约/拒绝': 12400, '复申人数': 1240, '复申成功率(%)': 10, '再次违约率(%)': 45, '建议': '继续拒贷' },
      { '风险标签': '轻微逾期(1-2次)', '曾经违约/拒绝': 16000, '复申人数': 6400, '复申成功率(%)': 80, '再次违约率(%)': 28, '建议': '可以申请' },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  风险标签,
  COUNT(DISTINCT user_id) as 曾经违约人数,
  SUM(CASE WHEN 有复申记录 = 1 THEN 1 ELSE 0 END) as 复申人数,
  SUM(CASE WHEN 复申成功 = 1 THEN 1 ELSE 0 END) * 100.0 / SUM(CASE WHEN 有复申记录 = 1 THEN 1 ELSE 0 END) as 复申成功率,
  SUM(CASE WHEN 复申成功 = 1 AND 再次违约 = 1 THEN 1 ELSE 0 END) * 100.0 /
    SUM(CASE WHEN 复申成功 = 1 THEN 1 ELSE 0 END) as 再次违约率
FROM 黑名单表
GROUP BY 风险标签
ORDER BY 再次违约率 DESC;`,
    conclusion: `# 黑名单客户复申情况分析 - 发现重复违约规律

## 关键发现：曾经违约的客户很容易再次违约

### 风险复现率
- **历史严重逾期（90天+）**：再次违约率68%（极高）
- **历史多次逾期（3-5次）**：再次违约率55%（很高）
- **曾被拒贷**：即使后来批准，再次违约率45%（高）
- **轻微逾期（1-2次）**：再次违约率28%（相对可控）

## 复申成功率与违约率的矛盾
- 有个现象很有趣：复申成功率越高，再次违约率越低
- 严重违约者（40%成功率）的再次违约率（68%）
- 轻微逾期者（80%成功率）的再次违约率（28%）
- **说明**：我们的拒贷决策在某种程度上是正确的

## 黑名单管理建议
- **严重逾期**：应该永久拒贷或极度谨慎
- **多次逾期**：长期限制（2年以上）
- **拒贷记录**：需要好转迹象才能重新考虑
- **轻微逾期**：可以在一段时间后考虑重新申请

## 分支D的重要发现
**黑名单不是简单的拒贷名单，而是需要根据严重程度差异化管理**`,
  },

  // ===== 阶段3：联合分析 - 分支E（时间因素） =====
  'analyze-e1': {
    title: '申请月份与违约率影响分析',
    headers: ['申请月份', '申请笔数', '平均违约率(%)', '与全年平均的偏差', '可能原因', '风险评级'],
    data: [
      { '申请月份': '1月（新年）', '申请笔数': 11200, '平均违约率(%)': 30, '与全年平均的偏差': '+9%', '可能原因': '年底压力、经济不确定性', '风险评级': '高风险' },
      { '申请月份': '2月（春节）', '申请笔数': 8900, '平均违约率(%)': 25, '与全年平均的偏差': '+4%', '可能原因': '节日消费压力', '风险评级': '中风险' },
      { '申请月份': '3月', '申请笔数': 10800, '平均违약率(%)': 19, '与全年平均的偏差': '-2%', '可能原因': '春天回暖、求职季', '风险评级': '正常' },
      { '申请月份': '6月（中期）', '申请笔数': 12200, '平均违约率(%)': 17, '与全年平均的偏差': '-4%', '可能原因': '上半年稳定期', '风险评级': '低风险' },
      { '申请月份': '9月（经济压力）', '申请笔数': 11500, '平均违约率(%)': 26, '与全年平均的偏差': '+5%', '可能原因': '3季度经济波动', '风险评级': '高风险' },
      { '申请月份': '12月（年末）', '申请笔数': 10300, '平均违约率(%)': 21, '与全年平均的偏差': '0%', '可能原因': '冲刺期，政策调整', '风险评级': '正常' },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  TO_CHAR(申请日期, 'MM') as 申请月份,
  COUNT(*) as 申请笔数,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 该月违约率,
  (SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) -
    (SELECT SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) FROM 贷款表) as 偏差
FROM 贷款表
WHERE 申请日期 BETWEEN '2023-01-01' AND '2024-01-31'
GROUP BY TO_CHAR(申请日期, 'MM')
ORDER BY 申请月份;`,
    conclusion: `# 申请月份与违约率影响分析 - 发现季节性规律

## 季节性模式发现

### 高风险月份
- **1月**：30% 违约率（+9%偏差）
  - 新年企业业绩压力
  - 去年借的钱开始还
  - 经济不确定性

- **9月**：26% 违约率（+5%偏差）
  - 3季度经济数据波动
  - 可能的金融风险事件
  - 秋季求职季，但就业压力大

### 低风险月份
- **6月**：17% 违约率（-4%偏差）
  - 上半年稳定期
  - 春招就业稳定
  - 经济基本面良好

- **3月**：19% 违约率（-2%偏差）
  - 新学年、新季度开始
  - 求职旺季
  - 经济恢复期

### 春节影响（2月特殊）
- 25% 违约率（+4%偏差）
- 不如1月严重，但高于平均
- 春节前的消费压力

## 风控启示
**不同月份应该有不同的审批标准：**
- **1月和9月**：提高审批门槛
- **6月和3月**：可适当放宽
- **差异可以达到13个百分点**（30% vs 17%）

## 分支E的发现
**时间确实是个重要的风险因子，需要动态调整风控标准**`,
  },

  'analyze-e2': {
    title: '申请量时间序列趋势',
    headers: ['时间周期', '申请笔数', '环比增长(%)', '平均违约率(%)', '违约笔数', '累计风险暴露'],
    data: [
      { '时间周期': '2023年1月', '申请笔数': 10500, '环比增长(%)': '-', '平均违约率(%)': 28, '违约笔数': 2940, '累计风险暴露': '高' },
      { '时间周期': '2023年6月', '申请笔数': 12800, '环比增长(%)': '+5.2%', '平均违约率(%)': 17, '违约笔数': 2176, '累计风险暴露': '中' },
      { '时间周期': '2023年9月', '申请笔数': 11200, '环比增长(%)': '+3.8%', '平均违约率(%)': 26, '违约笔数': 2912, '累计风险暴露': '高' },
      { '时间周期': '2023年12月', '申请笔数': 13500, '环比增长(%)': '+2.1%', '平均违约率(%)': 21, '违约笔数': 2835, '累计风险暴露': '中' },
      { '时间周期': '2024年1月', '申请笔数': 5500, '环比增长(%)': '-59.3%', '平均违约率(%)': 30, '违约笔数': 1650, '累计风险暴露': '极高' },
    ],
    totalRecords: 143000,
    type: 'table',
    code: `SELECT
  DATE_TRUNC('month', 申请日期) as 时间周期,
  COUNT(*) as 申请笔数,
  LAG(COUNT(*)) OVER (ORDER BY DATE_TRUNC('month', 申请日期)) as 前月申请数,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 违约率,
  SUM(CASE WHEN 是否违约 = 1 THEN 1 ELSE 0 END) as 违约笔数
FROM 贷款表
WHERE 申请日期 >= '2023-01-01'
GROUP BY DATE_TRUNC('month', 申请日期)
ORDER BY 时间周期;`,
    conclusion: `# 申请量时间序列趋势分析 - 发现关键问题！

## 时间序列变化

### 申请笔数变化
- **2023年全年**：平均每月11,500笔
- **2024年1月**：5,500笔（环比-59.3%！）
- 申请量出现了大幅下跌

### 违约率变化
- **2023年全年**：波动在17%-28%之间
- **2024年1月**：30%（创新高！）

## 关键异常信号！！

### 问题1：申请笔数下降但违约率上升
这个现象很奇怪：
- 如果申请量下降，说明来申请的客户在减少
- 但违约率反而上升了（30%）
- 说明**来申请的客户质量下降了**

### 问题2：是不是审批标准改变了？
可能的解释：
1. 最近放宽了审批标准，让更多风险用户通过
2. 或者审批流程出现问题
3. 或者某些风险用户被有针对性地推荐

### 问题3：累计风险暴露
- 虽然2024年1月申请数少
- 但违约率是全年最高（30%）
- 说明这些少量的申请都是高风险的

## 最严重的结论
**2024年1月的申请都是"坏"的申请**
- 可能是因为采用了新的审批策略
- 可能是因为风控部门没有及时更新规则
- 这需要立即调查原因

## 分支E的最终警告
**需要紧急审查最近的审批规则和流程**`,
  },

  // ===== 阶段4：输出结论 =====
  'output-1': {
    title: '建立风险评分模型',
    headers: ['特征', '权重', '评分标准', '说明'],
    data: [
      { '特征': '职业类型', '权重': '40%', '评分标准': '高危职业(0分) → 中性职业(60分) → 低危职业(100分)', '说明': '最重要的预测器' },
      { '特征': '申请金额', '权重': '35%', '评分标准': '50万+(0分) → 25-35万(40分) → <15万(100分)', '说明': '与违约呈强正相关' },
      { '特征': '申请时间', '权重': '15%', '评分标准': '高风险月份(1,9月)(60分) → 正常月份(80分) → 低风险月份(100分)', '说明': '需要动态调整' },
      { '特征': '借贷历史', '权重': '10%', '评分标准': '黑名单(0分) → 首贷(80分) → 成功复贷(100分)', '说明': '过往表现很重要' },
    ],
    totalRecords: 0,
    type: 'table',
    code: `-- 风险评分模型（简化版）
SELECT
  user_id,
  CASE
    WHEN 职业 IN ('个体户','其他') THEN 0
    WHEN 职业 IN ('销售','IT') THEN 60
    ELSE 100
  END * 0.4 +
  CASE
    WHEN 申请金额 > 50 THEN 0
    WHEN 申请金额 > 35 THEN 20
    WHEN 申请金额 > 25 THEN 40
    ELSE 100
  END * 0.35 +
  CASE
    WHEN EXTRACT(MONTH FROM 申请日期) IN (1, 9) THEN 60
    WHEN EXTRACT(MONTH FROM 申请日期) IN (3, 6) THEN 100
    ELSE 80
  END * 0.15 +
  CASE
    WHEN 有黑名单记录 THEN 0
    WHEN 贷款次数 = 0 THEN 80
    ELSE 100
  END * 0.10 as 综合风险分
FROM 贷款表;`,
    conclusion: `# 贷款风险评分模型构建

## 模型设计

### 模型框架
\`\`\`
综合风险分 = 职业评分*0.4 + 金额评分*0.35 + 时间评分*0.15 + 历史评分*0.1
总分：0-100分，分数越高越安全
\`\`\`

### 特征权重分配

**职业类型（40%）**
- 权重最高，因为重要性最强
- 高危：个体户、其他行业（0分）
- 中性：销售、IT工程师（60分）
- 低危：医生、公务员、教师（100分）

**申请金额（35%）**
- 权重次之，与违约强相关
- >50万（0分）
- 25-50万（40分）
- <25万（100分）

**申请时间（15%）**
- 权重较小但很关键
- 高风险月份1月、9月（60分）
- 正常月份（80分）
- 低风险月份3月、6月（100分）

**借贷历史（10%）**
- 权重最小但指示性强
- 黑名单（0分）
- 首次借贷（80分）
- 成功复贷或多次成功（100分）

## 风险分级标准
- **80-100分**：低风险，快速审批
- **60-79分**：中等风险，标准审批
- **40-59分**：高风险，严格审查
- **<40分**：极高风险，建议拒绝

## 模型优势
- 结构简单，易于理解
- 基于实际数据的强相关性
- 可以快速评分
- 易于动态调整权重

## 模型局限与下一步
- 需要更多样本进行验证
- 可以加入地域特征
- 可以加入宏观经济指标
- 需要定期进行模型回测和优化`,
  },

  'output-2': {
    title: '制定差异化风控策略',
    headers: ['客户风险等级', '风险分值', '审批策略', '定价策略', '贷后管理', '优先级'],
    data: [
      { '客户风险等级': '极高风险', '风险分值': '<40分', '审批策略': '直接拒绝或需总部特批', '定价策略': '-', '贷后管理': '-', '优先级': 'P0' },
      { '客户风险等级': '高风险', '风险分值': '40-59分', '审批策略': '需人工审核+多渠道验证', '定价策略': '基准利率+300bp', '贷后管理': '周期性电话回访', '优先级': 'P1' },
      { '客户风险等级': '中等风险', '风险分值': '60-79分', '审批策略': '标准审批流程', '定价策略': '基准利率+150bp', '贷后管理': '月度风险评估', '优先级': 'P2' },
      { '客户风险等级': '低风险', '风险分值': '80-100分', '审批策略': '快速审批(1天内)', '定价策略': '基准利率 或 -50bp', '贷后管理': '基础监测', '优先级': 'P3' },
    ],
    totalRecords: 0,
    type: 'table',
    code: `-- 差异化定价策略
SELECT
  user_id,
  综合风险分,
  CASE
    WHEN 综合风险分 >= 80 THEN '基准利率 - 50bp'
    WHEN 综合风险分 >= 60 THEN '基准利率 + 150bp'
    WHEN 综合风险分 >= 40 THEN '基准利率 + 300bp'
    ELSE '拒绝'
  END as 建议利率,
  CASE
    WHEN 综合风险分 >= 80 THEN '自动通过'
    WHEN 综合风险分 >= 60 THEN '标准流程'
    WHEN 综合风险分 >= 40 THEN '人工审查'
    ELSE '拒绝'
  END as 审批流程
FROM 评分结果;`,
    conclusion: `# 差异化风控和定价策略

## 策略核心
根据风险评分提供完全不同的审批和管理策略。

## 详细策略

### 极高风险（<40分）：拒绝策略
- **特征**：高危职业 + 大额 + 或有黑名单记录
- **操作**：直接拒绝，或需C级主管特批
- **目标**：完全避免这类风险
- **预期违约率**：>40%

### 高风险（40-59分）：严控策略
- **特征**：某个维度风险高，但不是全部
- **审批**：必须人工审核，需多渠道验证
- **定价**：基准利率+300bp（利率差300个基点）
- **贷后**：周期性电话回访，及时发现问题
- **额度上限**：10-15万
- **预期违约率**：20-30%

### 中等风险（60-79分）：标准策略
- **特征**：整体平衡，某些维度一般
- **审批**：标准流程即可
- **定价**：基准利率+150bp
- **贷后**：月度风险评估
- **额度上限**：30-40万
- **预期违约率**：12-18%

### 低风险（80-100分）：优惠策略
- **特征**：低危职业+高收入+小额或有成功历史
- **审批**：快速审批，1天内决策
- **定价**：基准利率，甚至-50bp（优惠）
- **贷后**：基础监测即可
- **额度上限**：50万以上
- **目标**：快速获取优质客户
- **预期违约率**：<10%

## 定价逻辑
- 低风险客户（违约率<10%）利率最低，快速审批
- 中等风险客户（违约率15%）加价150bp来补偿风险
- 高风险客户（违约率25%）加价300bp
- 极高风险直接拒绝而不是加价

## 预期效果
如果执行这个策略：
- 整体违约率应该从22%下降到15%左右
- 低风险客户的获取成本大幅降低
- 高风险客户的收益能覆盖违约成本`,
  },

  'output-3': {
    title: '最终验证与优化建议',
    headers: ['验证维度', '验证方法', '预期结果', '关键指标', '优化方向'],
    data: [
      { '验证维度': '模型准确性', '验证方法': '回测历史数据，计算ROC-AUC', '预期结果': 'AUC > 0.75', '关键指标': '违约预测准确率', '优化方向': '加入更多特征' },
      { '验证维度': '定价充分性', '验证方法': '计算不同评分段的实际违约成本', '预期结果': '定价能覆盖违约率', '关键指标': '利息收益vs违约损失', '优化方向': '动态调整利率' },
      { '验证维度': '业务可行性', '验证方法': '模拟新规则下的通过率', '预期结果': '通过率40-60%', '关键指标': '审批通过笔数', '优化方向': '平衡风险和收入' },
      { '验证维度': '时间动态性', '验证方法': '按月份重新评估风险水位', '预期结果': '及时发现异常期', '关键指标': '高风险期的识别率', '优化方向': '建立预警机制' },
    ],
    totalRecords: 0,
    type: 'table',
    code: `-- 模型验证和回测
WITH model_predictions AS (
  SELECT
    user_id,
    综合风险分,
    CASE WHEN 综合风险分 >= 80 THEN 'low_risk'
         WHEN 综合风险分 >= 60 THEN 'medium_risk'
         WHEN 综合风险分 >= 40 THEN 'high_risk'
         ELSE 'very_high_risk'
    END as 预测等级,
    是否违约 as 实际违约
  FROM 评分结果
)
SELECT
  预测等级,
  SUM(CASE WHEN 实际违约 = 1 THEN 1 ELSE 0 END) as 违约人数,
  COUNT(*) as 总人数,
  SUM(CASE WHEN 实际违约 = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as 实际违约率
FROM model_predictions
GROUP BY 预测等级;`,
    conclusion: `# 最终验证与优化建议

## 验证框架

### 1. 模型准确性验证
**方法**：使用ROC曲线和AUC指标
- 在历史数据上进行回测
- 验证模型对违约的预测能力

**预期目标**：AUC > 0.75
- 0.75-0.80：模型效果不错
- 0.80-0.90：模型效果很好
- >0.90：模型效果优秀

**关键指标**：
- 对低风险客户的识别准确率
- 对高风险客户的召回率

### 2. 定价充分性验证
**方法**：计算每个风险段的成本-收益
- 预期违约率 × 平均损失 = 成本
- 利率收益 = 收入
- 收入 - 成本 = 净收益

**预期结果**：
- 低风险：利率低但违约少，净收益稳定
- 中风险：加价补偿风险
- 高风险：高利率覆盖高违约率

### 3. 业务可行性验证
**方法**：模拟新规则下的审批通过率
- 大约有多少% 的申请会被拒绝？
- 对收入有什么影响？

**预期目标**：通过率40-60%
- 太高：说明拒绝不够
- 太低：说明标准过于严格

### 4. 时间动态性验证
**方法**：持续监测高风险期
- 每月更新评分阈值
- 识别异常的申请特征

**关键指标**：
- 是否及时发现2024年1月的异常？
- 能否预警下一个高风险期？

## 优化建议

### 短期（1-3个月）
1. **紧急调查2024年1月的审批异常**
   - 为什么申请量下降但风险上升？
   - 审批标准有没有被改变？
   - 有没有人工干预？

2. **立即改进高风险的定价**
   - 检查现有高风险客户的利率设置
   - 确保能够覆盖违约成本

3. **建立监测预警**
   - 按月份跟踪违约率
   - 一旦发现异常立即预警

### 中期（3-6个月）
1. **丰富模型特征**
   - 加入地域特征（地区风险差异）
   - 加入宏观经济指标
   - 加入客户行为特征

2. **进行A/B测试**
   - 部分客户用新规则，部分用旧规则
   - 对比实际效果

3. **优化定价模型**
   - 从固定加点改为动态定价
   - 根据实时风险调整利率

### 长期（6个月以上）
1. **建立完整的风控体系**
   - 准入前风控（评分模型）
   - 准入后风控（行为监测）
   - 风险化解（催收、处置）

2. **机器学习升级**
   - 使用更复杂的算法
   - 自动学习特征组合
   - 不断优化模型

3. **贷全生命周期管理**
   - 申请期：严格评估
   - 审批期：快速决策
   - 放款期：准确验证
   - 还款期：主动管理
   - 逾期期：高效催收

## 关键成功指标（KPI）
- 整体违约率从22% → 15%以下
- 低风险客户通过率 >90%
- 高风险客户拒绝率 >80%
- 模型AUC > 0.80
- 定价能覆盖违约成本

## 最终建议
**这个分析框架是可行的，应该立即执行！**
- 先处理2024年1月的危急问题
- 然后逐步推出新的评分和定价规则
- 建立持续优化的机制`,
  },

  // ===== 计算/分析节点（紫色） =====
  'compute-1': {
    title: '申请人单维度特征统计',
    headers: ['特征维度', '特征值', '人数', '占比(%)'],
    data: [
      // 年龄段分析
      { '特征维度': '年龄段', '特征值': '25-30岁', '人数': 40012, '占比(%)': 28.0 },
      { '特征维度': '年龄段', '特征值': '31-40岁', '人数': 64350, '占比(%)': 45.0 },
      { '特征维度': '年龄段', '特征值': '41-50岁', '人数': 28638, '占比(%)': 20.0 },
      { '特征维度': '年龄段', '特征值': '其他', '人数': 10000, '占比(%)': 7.0 },
      // 月收入分析
      { '特征维度': '月收入', '特征值': '10-15k', '人数': 45760, '占比(%)': 32.0 },
      { '特征维度': '月收入', '特征值': '15-25k', '人数': 68640, '占比(%)': 48.0 },
      { '特征维度': '月收入', '特征值': '25k以上', '人数': 28600, '占比(%)': 20.0 },
      // 职业类型分析
      { '特征维度': '职业类型', '特征值': '企业员工', '人数': 64350, '占比(%)': 45.0 },
      { '特征维度': '职业类型', '特征值': '个体商户', '人数': 28600, '占比(%)': 20.0 },
      { '特征维度': '职业类型', '特征值': '医疗教育', '人数': 21450, '占比(%)': 15.0 },
      { '特征维度': '职业类型', '特征值': '公务员', '人数': 14300, '占比(%)': 10.0 },
      { '特征维度': '职业类型', '特征值': '其他', '人数': 14300, '占比(%)': 10.0 },
      // 申请金额分析
      { '特征维度': '申请金额', '特征值': '10-30万', '人数': 93050, '占比(%)': 65.0 },
      { '特征维度': '申请金额', '特征值': '30-50万', '人数': 35750, '占比(%)': 25.0 },
      { '特征维度': '申请金额', '特征值': '50万以上', '人数': 14200, '占比(%)': 10.0 },
      // 婚姻状况分析
      { '特征维度': '婚姻状况', '特征值': '已婚', '人数': 88860, '占比(%)': 62.0 },
      { '特征维度': '婚姻状况', '特征值': '未婚', '人数': 54340, '占比(%)': 38.0 },
    ],
    totalRecords: 143200,
    type: 'table',
    conclusion: `# 申请人单维度特征分析报告

本分析从5个主要维度对贷款申请人的基本特征进行统计，为后续的交叉分析和风险建模提供基础。

## 发现1：申请人年龄以中年为主
- **31-40岁**是申请的绝对主力军（45%，约64K人）
- **25-30岁**次之（28%，约40K人）
- 两个年龄段占比合计73%
- **结论**：中青年是主要目标客户群

## 发现2：收入水平以中等收入为主
- **15-25k**是主流收入段（48%，约68.6K人）
- **10-15k**次之（32%，约45.7K人）
- 两个区间占比合计80%
- **结论**：中等收入人群是主要客户

## 发现3：职业结构差异明显
- **企业员工**占比最高（45%，约64.3K人），风险相对可控
- **个体商户**占比20%（约28.6K人），收入波动较大，需要关注
- **医疗教育**占比15%（约21.4K人），风险较低
- **公务员**占比10%（约14.3K人），风险最低
- **其他**占比10%（约14.3K人）
- **结论**：需要按职业类型进行差异化风险定价

## 发现4：申请金额以中低额度为主
- **10-30万**是主流（65%，约93K人），风险相对可控
- **30-50万**占25%（约35.75K人）
- **50万以上**占10%（约14.2K人），需要严格审批
- **结论**：大部分申请金额在中低范围，金额越大风险越需要关注

## 发现5：已婚人群占多数
- **已婚**占62%（约88.9K人）
- **未婚**占38%（约54.3K人）
- **结论**：已婚人群稳定性更高，这可能是后续交叉分析的重要维度`,
    code: `# 输入数据：data-1, data-2, data-3（原始用户、申请、还款数据）

import pandas as pd
import numpy as np

# 从三个原始数据表读取数据
user_df = load_data('data-1')      # 用户基本信息
application_df = load_data('data-2')  # 贷款申请数据
repayment_df = load_data('data-3')    # 还款历史数据

# 合并数据（以application为主表）
merged_df = application_df.merge(user_df, on='user_id', how='left')

# 1. 年龄段分析
age_dist = merged_df.groupby(pd.cut(merged_df['age'],
                                     bins=[0, 30, 40, 50, 100],
                                     labels=['25-30岁', '31-40岁', '41-50岁', '其他'])).size()
age_pct = (age_dist / len(merged_df) * 100).round(1)

# 2. 月收入分析
income_dist = merged_df.groupby(pd.cut(merged_df['monthly_income'],
                                       bins=[0, 15000, 25000, 100000],
                                       labels=['10-15k', '15-25k', '25k以上'])).size()
income_pct = (income_dist / len(merged_df) * 100).round(1)

# 3. 职业类型分析
occupation_dist = merged_df.groupby('occupation').size()
occupation_pct = (occupation_dist / len(merged_df) * 100).round(1)

# 4. 申请金额分析
amount_dist = merged_df.groupby(pd.cut(merged_df['loan_amount']/10000,
                                       bins=[0, 30, 50, 1000],
                                       labels=['10-30万', '30-50万', '50万以上'])).size()
amount_pct = (amount_dist / len(merged_df) * 100).round(1)

# 5. 婚姻状况分析
marital_dist = merged_df.groupby('marital_status').size()
marital_pct = (marital_dist / len(merged_df) * 100).round(1)

# 组织成长表格式输出
results = []
for dim in ['年龄段', '月收入', '职业类型', '申请金额', '婚姻状况']:
    if dim == '年龄段':
        for val, count in age_dist.items():
            results.append({
                '特征维度': '年龄段',
                '特征值': val,
                '人数': count,
                '占比(%)': age_pct[val]
            })
    # ... 类似处理其他维度 ...

output_df = pd.DataFrame(results)
print(output_df)`,
  },

  'compute-2': {
    title: '年龄-收入交叉分析',
    headers: ['年龄段', '低收入(8-12k)', '中等收入(12-20k)', '高收入(20k+)', '平均违约率(%)'],
    data: [
      { '年龄段': '25-30岁', '低收入(8-12k)': 85, '中等收入(12-20k)': 120, '高收入(20k+)': 45, '平均违约率(%)': 24 },
      { '年龄段': '31-40岁', '低收入(8-12k)': 120, '中等收入(12-20k)': 380, '高收入(20k+)': 180, '平均违约率(%)': 18 },
      { '年龄段': '41-50岁', '低收入(8-12k)': 60, '中等收入(12-20k)': 150, '高收入(20k+)': 140, '平均违约率(%)': 15 },
      { '年龄段': '50岁以上', '低收入(8-12k)': 25, '中等收入(12-20k)': 50, '高收入(20k+)': 60, '平均违约率(%)': 22 },
    ],
    totalRecords: 143000,
    type: 'table',
    conclusion: `# 年龄-收入交叉分析 - 发现关键规律！

## 关键发现！

### 发现1：年轻低收入风险高
- **25-30岁+低收入**：违约率24%
- 年轻人群借贷需求强但收入不稳定

### 发现2：中年中等收入最安全
- **31-40岁+中等收入**：违约率18%
- 这是最大的客户群体（380人）

### 发现3：高收入相对安全
- 跨所有年龄段，高收入组的违约率都较低
- 高收入成为强保护因素

### 发现4：年龄越大越稳定
- 41-50岁违约率最低（15%）
- 年龄与还款稳定性正相关

## 风险分组
- **高风险**：年轻（<30）+低收入
- **中风险**：中年+中等收入
- **低风险**：40+岁或高收入`,
    code: `# 输入数据：compute-1（申请人单维度特征统计）

# 基于compute-1的单维度分析，进行年龄和收入的交叉分析
import pandas as pd

# 从原始merged_df中进行二维交叉分析
cross_df = merged_df.groupby([
    pd.cut(merged_df['age'], bins=[0, 30, 40, 50, 100],
           labels=['25-30岁', '31-40岁', '41-50岁', '50岁以上']),
    pd.cut(merged_df['monthly_income'], bins=[0, 12000, 20000, 100000],
           labels=['低收入(8-12k)', '中等收入(12-20k)', '高收入(20k+)'])
]).size().unstack(fill_value=0)

# 计算各组的违约率
default_cross = merged_df.groupby([
    pd.cut(merged_df['age'], bins=[0, 30, 40, 50, 100],
           labels=['25-30岁', '31-40岁', '41-50岁', '50岁以上']),
    pd.cut(merged_df['monthly_income'], bins=[0, 12000, 20000, 100000],
           labels=['低收入(8-12k)', '中等收入(12-20k)', '高收入(20k+)'])
])['is_default'].agg(['sum', 'count'])
default_cross['违约率(%)'] = (default_cross['sum'] / default_cross['count'] * 100).round(1)

# 重构为长表格式
results = []
for age_group in cross_df.index:
    result_row = {
        '年龄段': age_group,
        '低收入(8-12k)': cross_df.loc[age_group, '低收入(8-12k)'],
        '中等收入(12-20k)': cross_df.loc[age_group, '中等收入(12-20k)'],
        '高收入(20k+)': cross_df.loc[age_group, '高收入(20k+)'],
        '平均违约率(%)': default_cross.loc[age_group, '违约率(%)'].mean()
    }
    results.append(result_row)

output_df = pd.DataFrame(results)
print(output_df)`,
  },

  'compute-3': {
    title: '职业风险分析',
    headers: ['职业类型', '申请数', '占比(%)', '违约人数', '违约率(%)', '平均申请额(万)'],
    data: [
      { '职业类型': '软件/IT工程师', '申请数': 18500, '占比(%)': 13.0, '违约人数': 2590, '违约率(%)': 14, '平均申请额(万)': 28 },
      { '职业类型': '销售/市场类', '申请数': 22300, '占比(%)': 15.6, '违约人数': 4228, '违约率(%)': 19, '平均申请额(万)': 22 },
      { '职业类型': '个体/商户', '申请数': 28600, '占比(%)': 20.0, '违约人数': 8008, '违约率(%)': 28, '平均申请额(万)': 35 },
      { '职业类型': '医疗/教育工作者', '申请数': 16200, '占比(%)': 11.3, '违约人数': 1458, '违约率(%)': 9, '平均申请额(万)': 20 },
      { '职业类型': '公务员/事业单位', '申请数': 14800, '占比(%)': 10.4, '违约人数': 1480, '违约率(%)': 10, '平均申请额(万)': 18 },
      { '职业类型': '其他工作者', '申请数': 42600, '占比(%)': 29.8, '违约人数': 12348, '违约率(%)': 29, '平均申请额(万)': 24 },
    ],
    totalRecords: 143000,
    type: 'table',
    conclusion: `# 职业风险分析 - 发现最强风险信号！

## 关键发现！！

### 高风险职业群体
- **个体/商户**：违约率28%（申请数最多：20%）
- **其他工作者**：违约率29%（占比最大：30%）
- 这两类合起来占申请总数的50%，但都是高风险

### 中等风险职业
- **销售/市场类**：违约率19%
- 申请额度较低，但风险不低

### 低风险职业群体
- **医疗/教育工作者**：违约率9%（最低！）
- **公务员/事业单位**：违约率10%
- 这两类虽然申请数较少，但非常稳定

## 重要洞察
**职业是最强的风险预测器！**
- 同样是申请30万，个体商户（28%违约）vs医生（9%违约）
- 风险相差3倍！`,
    code: `# 输入数据：compute-1（申请人单维度特征统计）+ repayment_df

# 按职业类型分析风险
import pandas as pd

occupation_analysis = merged_df.groupby('occupation').agg({
    'application_id': 'count',  # 申请数
    'is_default': 'sum',        # 违约人数
    'loan_amount': 'mean',      # 平均申请额
}).round(2)

occupation_analysis.columns = ['申请数', '违约人数', '平均申请额(万)']
occupation_analysis['占比(%)'] = (occupation_analysis['申请数'] / occupation_analysis['申请数'].sum() * 100).round(1)
occupation_analysis['违约率(%)'] = (occupation_analysis['违约人数'] / occupation_analysis['申请数'] * 100).round(0)

# 按申请数降序排序
occupation_analysis = occupation_analysis.sort_values('申请数', ascending=False)
occupation_analysis['平均申请额(万)'] = (occupation_analysis['平均申请额(万)'] / 10000).round(0)

# 重构为长表格式
results = []
for occupation, row in occupation_analysis.iterrows():
    results.append({
        '职业类型': occupation,
        '申请数': int(row['申请数']),
        '占比(%)': row['占比(%)'],
        '违约人数': int(row['违约人数']),
        '违约率(%)': int(row['违约率(%)']),
        '平均申请额(万)': int(row['平均申请额(万)'])
    })

output_df = pd.DataFrame(results)
print(output_df)`,
  },

  'compute-4': {
    title: '逾期率统计',
    headers: ['时间段', '贷款总数', '逾期笔数', '逾期率(%)', '平均逾期天数', '严重逾期比(%)'],
    data: [
      { '时间段': '2023年Q1', '贷款总数': 31500, '逾期笔数': 6300, '逾期率(%)': 20, '平均逾期天数': 18, '严重逾期比(%)': 8 },
      { '时间段': '2023年Q2', '贷款总数': 28800, '逾期笔数': 5040, '逾期率(%)': 17.5, '平均逾期天数': 15, '严重逾期比(%)': 6 },
      { '时间段': '2023年Q3', '贷款总数': 35200, '逾期笔数': 9240, '逾期率(%)': 26.3, '平均逾期天数': 22, '严重逾期比(%)': 11 },
      { '时间段': '2023年Q4', '贷款总数': 42000, '逾期笔数': 8820, '逾期率(%)': 21, '平均逾期天数': 16, '严重逾期比(%)': 7 },
      { '时间段': '2024年Q1', '贷款总数': 5500, '逾期笔数': 1650, '逾期率(%)': 30, '平均逾期天数': 25, '严重逾期比(%)': 14 },
    ],
    totalRecords: 143000,
    type: 'table',
    conclusion: `# 逾期率统计分析 - 发现时间规律！

## 关键发现！！

### 时间趋势分析
- **2023年Q1**：20% 逾期率（基础水平）
- **2023年Q2**：17.5% 逾期率（改善）
- **2023年Q3**：26.3% 逾期率（恶化！）
- **2023年Q4**：21% 逾期率（反弹）
- **2024年Q1**：30% 逾期率（急速恶化！！）

### 关键信号
- **Q3明显异常**（26.3%）
- **2024年Q1最危险**（30%）：最近审批的贷款风险最高！

### 严重逾期趋势
- Q3和2024Q1的严重逾期比最高（11%和14%）
- 这不仅是逾期增加，而是逾期在恶化`,
    code: `# 输入数据：data-3（还款历史数据）+ application_df

# 按月份/季度统计逾期情况
import pandas as pd

repayment_df['期限'] = pd.to_datetime(repayment_df['application_date'])
repayment_df['时间段'] = repayment_df['期限'].dt.to_period('Q')

quarterly_analysis = repayment_df.groupby('时间段').agg({
    'application_id': 'count',      # 贷款总数
    'is_overdue': 'sum',            # 逾期笔数
    'overdue_days': 'mean',         # 平均逾期天数
    'is_severe_overdue': 'sum',     # 严重逾期笔数
}).round(2)

quarterly_analysis.columns = ['贷款总数', '逾期笔数', '平均逾期天数', '严重逾期笔数']
quarterly_analysis['逾期率(%)'] = (quarterly_analysis['逾期笔数'] / quarterly_analysis['贷款总数'] * 100).round(1)
quarterly_analysis['严重逾期比(%)'] = (quarterly_analysis['严重逾期笔数'] / quarterly_analysis['贷款总数'] * 100).round(1)

# 重构为长表格式
results = []
for period, row in quarterly_analysis.iterrows():
    results.append({
        '时间段': str(period),
        '贷款总数': int(row['贷款总数']),
        '逾期笔数': int(row['逾期笔数']),
        '逾期率(%)': row['逾期率(%)'],
        '平均逾期天数': int(row['平均逾期天数']),
        '严重逾期比(%)': row['严重逾期比(%)']
    })

output_df = pd.DataFrame(results)
print(output_df)`,
  },

  'compute-5': {
    title: '金额与违约关系分析',
    headers: ['金额区间(万)', '申请笔数', '占比(%)', '逾期笔数', '逾期率(%)', '平均期限(月)'],
    data: [
      { '金额区间(万)': '10-15', '申请笔数': 42900, '占比(%)': 30, '逾期笔数': 6006, '逾期率(%)': 14, '平均期限(月)': 18 },
      { '金额区间(万)': '15-25', '申请笔数': 50050, '占比(%)': 35, '逾期笔数': 8508, '逾期率(%)': 17, '平均期限(月)': 22 },
      { '金额区间(万)': '25-35', '申请笔数': 32200, '占比(%)': 22.5, '逾期笔数': 7408, '逾期率(%)': 23, '平均期限(月)': 26 },
      { '金额区间(万)': '35-50', '申请笔数': 14300, '占比(%)': 10, '逾期笔数': 3861, '逾期率(%)': 27, '平均期限(月)': 30 },
      { '金额区间(万)': '50以上', '申请笔数': 3550, '占比(%)': 2.5, '逾期笔数': 1347, '逾期率(%)': 38, '平均期限(月)': 33 },
    ],
    totalRecords: 143000,
    type: 'table',
    conclusion: `# 金额与违约关系分析 - 发现强相关性！

## 核心发现：金额越大，违约率越高！

### 违约率与金额的强正相关
- **10-15万**：14% 违约率（最安全）
- **15-25万**：17% 违约率
- **25-35万**：23% 违约率
- **35-50万**：27% 违约率
- **50万以上**：38% 违约率（最危险！）

### 关键数据
- 从10-15万到50万+，违约率翻了2.7倍！
- 大额贷款（50万+）虽然只占2.5%，但违约率最高
- 期限越长，违约的概率越高

## 重要结论
**金额是第二强的风险预测器**（仅次于职业）`,
    code: `# 输入数据：compute-1（申请人特征）+ repayment_df

# 按贷款金额区间分析违约率
import pandas as pd

amount_analysis = merged_df.groupby(pd.cut(merged_df['loan_amount']/10000,
                                           bins=[0, 15, 25, 35, 50, 1000],
                                           labels=['10-15', '15-25', '25-35', '35-50', '50以上'])).agg({
    'application_id': 'count',          # 申请笔数
    'is_default': 'sum',                # 逾期笔数
    'loan_term_months': 'mean'          # 平均期限
}).round(2)

amount_analysis.columns = ['申请笔数', '逾期笔数', '平均期限(月)']
amount_analysis['占比(%)'] = (amount_analysis['申请笔数'] / amount_analysis['申请笔数'].sum() * 100).round(1)
amount_analysis['逾期率(%)'] = (amount_analysis['逾期笔数'] / amount_analysis['申请笔数'] * 100).round(0)

# 重构为长表格式
results = []
for amount_range, row in amount_analysis.iterrows():
    results.append({
        '金额区间(万)': amount_range,
        '申请笔数': int(row['申请笔数']),
        '占比(%)': row['占比(%)'],
        '逾期笔数': int(row['逾期笔数']),
        '逾期率(%)': int(row['逾期率(%)']),
        '平均期限(月)': int(row['平均期限(月)'])
    })

output_df = pd.DataFrame(results)
print(output_df)`,
  },

  'compute-6': {
    title: '首贷vs复贷对比',
    headers: ['客户类型', '样本数', '占比(%)', '违约人数', '违约率(%)', '平均申请额(万)', '平均期限(月)'],
    data: [
      { '客户类型': '首次借贷者', '样本数': 89500, '占比(%)': 62.6, '违约人数': 19686, '违约率(%)': 22, '平均申请额(万)': 22, '平均期限(月)': 21 },
      { '客户类型': '复贷客户(2次)', '样本数': 35500, '占比(%)': 24.8, '违约人数': 5325, '违约率(%)': 15, '平均申请额(万)': 26, '平均期限(月)': 24 },
      { '客户类型': '多次借贷者(3次+)', '样本数': 18000, '占比(%)': 12.6, '违约人数': 1620, '违约率(%)': 9, '平均申请额(万)': 28, '平均期限(月)': 26 },
    ],
    totalRecords: 143000,
    type: 'table',
    conclusion: `# 首贷vs复贷违约率对比

## 关键发现：有借贷历史的客户风险更低！

### 违约率对比
- **首次借贷**：22% 违约率（最高）
- **复贷（2次）**：15% 违约率（改善）
- **多次借贷（3次+）**：9% 违约率（最低）

### 关键洞察
- 有成功还款历史的客户更可靠
- 每多一次成功的借贷，违约风险大幅下降
- 多次借贷的客户虽然申请额度更大（28万），但违约率反而最低（9%）

## 业务启示
- **首贷客户**需要更严格的审批
- **复贷客户**可以从宽考虑
- **多次借贷客户**是优质客户，应该优先支持`,
    code: `# 输入数据：data-2（贷款申请数据）+ repayment_df

# 统计首贷、复贷、多次借贷客户的违约率差异
import pandas as pd

# 计算每个用户的借贷次数
user_borrow_count = merged_df.groupby('user_id')['application_id'].count().rename('borrow_times')
merged_df_with_count = merged_df.merge(user_borrow_count, on='user_id')

# 分类：首贷、复贷（2次）、多次借贷（3次+）
merged_df_with_count['customer_type'] = merged_df_with_count['borrow_times'].apply(
    lambda x: '首次借贷者' if x == 1 else ('复贷客户(2次)' if x == 2 else '多次借贷者(3次+)')
)

borrow_analysis = merged_df_with_count.groupby('customer_type').agg({
    'user_id': 'count',             # 样本数
    'is_default': 'sum',            # 违约人数
    'loan_amount': 'mean',          # 平均申请额
    'loan_term_months': 'mean'      # 平均期限
}).round(2)

borrow_analysis.columns = ['样本数', '违约人数', '平均申请额(万)', '平均期限(月)']
borrow_analysis['占比(%)'] = (borrow_analysis['样本数'] / borrow_analysis['样本数'].sum() * 100).round(1)
borrow_analysis['违约率(%)'] = (borrow_analysis['违约人数'] / borrow_analysis['样本数'] * 100).round(0)
borrow_analysis['平均申请额(万)'] = (borrow_analysis['平均申请额(万)'] / 10000).round(0)
borrow_analysis['平均期限(月)'] = borrow_analysis['平均期限(月)'].astype(int)

# 重构为长表格式
results = []
for customer_type, row in borrow_analysis.iterrows():
    results.append({
        '客户类型': customer_type,
        '样本数': int(row['样本数']),
        '占比(%)': row['占比(%)'],
        '违约人数': int(row['违约人数']),
        '违约率(%)': int(row['违约率(%)']),
        '平均申请额(万)': int(row['平均申请额(万)']),
        '平均期限(月)': row['平均期限(月)']
    })

output_df = pd.DataFrame(results)
print(output_df)`,
  },

  'compute-7': {
    title: '特征重要性排序',
    headers: ['排序', '特征名称', '重要性分数(0-1)', '与违约的相关系数', '在风控模型中的作用'],
    data: [
      { '排序': '1', '特征名称': '职业类型', '重要性分数(0-1)': 0.92, '与违约的相关系数': 0.78, '在风控模型中的作用': '最强预测器' },
      { '排序': '2', '特征名称': '申请金额', '重要性分数(0-1)': 0.88, '与违约的相关系数': 0.73, '在风控模型中的作用': '第二强预测器' },
      { '排序': '3', '特征名称': '申请月份/时间', '重要性分数(0-1)': 0.76, '与违约的相关系数': 0.62, '在风控模型中的作用': '重要环境因子' },
      { '排序': '4', '特征名称': '年龄', '重要性分数(0-1)': 0.68, '与违约的相关系数': -0.55, '在风控模型中的作用': '缓冲因素' },
      { '排序': '5', '特征名称': '月收入', '重要性分数(0-1)': 0.72, '与违约的相关系数': -0.61, '在风控模型中的作用': '保护因素' },
    ],
    totalRecords: 143000,
    type: 'table',
    conclusion: `# 特征重要性排序 - 揭示最强风险预测器！

## 排序结果分析

### Top 3 最重要的特征

**第1名：职业类型（0.92）**
- 与违约的相关系数：0.78（最强）
- 是我们最强的预测器
- 不同职业的违约率差异巨大（9%-29%）

**第2名：申请金额（0.88）**
- 与违约的相关系数：0.73
- 金额与违约率呈明显正相关
- 50万+的违约率是10-15万的2.7倍

**第3名：申请时间/月份（0.76）**
- 与违约的相关系数：0.62
- 最近申请的贷款风险上升
- 2024年1月出现异常

## 模型构建建议
优先使用Top 3特征构建基础模型：
- 风险评分 = 职业权重 * 0.4 + 金额权重 * 0.35 + 时间权重 * 0.25`,
    code: `# 输入数据：compute-2, compute-3, compute-4, compute-5, compute-6（所有分析结果）

# 使用特征重要性方法（如XGBoost）计算特征的重要性
from sklearn.ensemble import RandomForestClassifier
import pandas as pd

# 准备特征矩阵
X = merged_df[[
    'occupation',           # 职业
    'loan_amount',          # 申请金额
    'application_month',    # 申请时间/月份
    'age',                  # 年龄
    'monthly_income'        # 月收入
]]

# 目标变量：是否违约
y = merged_df['is_default']

# 特征编码和标准化
X_processed = preprocess_features(X)

# 训练随机森林模型
rf_model = RandomForestClassifier(n_estimators=100, random_state=42)
rf_model.fit(X_processed, y)

# 获取特征重要性
feature_importance = pd.DataFrame({
    '特征名称': ['职业类型', '申请金额', '申请月份/时间', '年龄', '月收入'],
    '重要性分数(0-1)': rf_model.feature_importances_
}).sort_values('重要性分数(0-1)', ascending=False)

# 计算与违约的相关系数
feature_importance['与违约的相关系数'] = [
    merged_df.groupby('occupation')['is_default'].mean().std(),
    merged_df['loan_amount'].corr(merged_df['is_default']),
    merged_df.groupby('application_month')['is_default'].mean().std(),
    merged_df['age'].corr(merged_df['is_default']),
    merged_df['monthly_income'].corr(merged_df['is_default'])
][:5]

# 添加风控模型中的作用
feature_importance['在风控模型中的作用'] = ['最强预测器', '第二强预测器', '重要环境因子',
                                  '缓冲因素', '保护因素']

# 添加排序
feature_importance['排序'] = range(1, len(feature_importance) + 1)

output_df = feature_importance[['排序', '特征名称', '重要性分数(0-1)', '与违约的相关系数', '在风控模型中的作用']]
print(output_df)`,
  },

  // ===== 图表节点（红色） =====
  'chart-1': {
    title: '不同年龄和收入群体的违约率分布',
    headers: ['年龄段', '低收入(8-12k)', '中等收入(12-20k)', '高收入(20k+)'],
    data: [
      { '年龄段': '25-30岁', '低收入(8-12k)': 24, '中等收入(12-20k)': 20, '高收入(20k+)': 14 },
      { '年龄段': '31-40岁', '低收入(8-12k)': 19, '中等收入(12-20k)': 16, '高收入(20k+)': 12 },
      { '年龄段': '41-50岁', '低收入(8-12k)': 18, '中等收入(12-20k)': 14, '高收入(20k+)': 10 },
    ],
    totalRecords: 143000,
    type: 'chart',
    chartType: 'scatter',
    conclusion: `# 不同年龄和收入群体的违约率分布

该散点图展示了各年龄段内不同收入水平的违约率情况，清晰显示收入水平和年龄对风险的联合影响。

## 关键洞察

**1. 收入是最强的保护因素**
- 在同一年龄段内，收入每上升一个等级，违约率平均下降4-6个百分点
- 25-30岁：低收入24% → 高收入14%（降幅最大，10%）
- 31-40岁：低收入19% → 高收入12%（降幅7%）
- 41-50岁：低收入18% → 高收入10%（降幅8%）

**2. 年龄也是重要风险因素**
- 年龄越大，同一收入等级的违约率越低
- 低收入群体：25-30岁(24%) > 31-40岁(19%) > 41-50岁(18%)
- 高收入群体：25-30岁(14%) > 31-40岁(12%) > 41-50岁(10%)

**3. 高风险人群明确**
- 最高风险：年轻低收入（25-30岁低收入，违约率24%）
- 风险可控：中年高收入（31-40岁高收入，违约率12%）
- 最低风险：高龄高收入（41-50岁高收入，违约率10%）

## 风险分级建议

| 风险等级 | 违约率范围 | 对应人群 | 建议措施 |
|---------|---------|---------|---------|
| 高风险 | >20% | 年轻低收入 | 严格审批，要求担保或抵押 |
| 中高风险 | 16%-20% | 年轻中收入、中年低收入 | 标准审批，核实收入来源 |
| 中风险 | 12%-16% | 中年中收入、高龄低收入 | 简化审批，常规审核 |
| 低风险 | <12% | 中年高收入、高龄任何收入 | 快速通过，额度可加大 |`,
    code: `# 输入数据：compute-2（年龄-收入交叉分析）

# 使用compute-2的数据直接生成散点图
import pandas as pd
import matplotlib.pyplot as plt

# 从compute-2获取的交叉分析数据
scatter_data = {
    '年龄段': ['25-30岁', '25-30岁', '25-30岁', '31-40岁', '31-40岁', '31-40岁',
               '41-50岁', '41-50岁', '41-50岁'],
    '收入等级': ['低收入(8-12k)', '中等收入(12-20k)', '高收入(20k+)',
               '低收入(8-12k)', '中等收入(12-20k)', '高收入(20k+)',
               '低收入(8-12k)', '中等收入(12-20k)', '高收入(20k+)'],
    '平均年龄': [27.5, 27.5, 27.5, 35.5, 35.5, 35.5, 45.5, 45.5, 45.5],
    '平均收入': [10, 16, 28, 10, 16, 28, 10, 16, 28],
    '违约率(%)': [24, 20, 14, 19, 16, 12, 18, 14, 10]
}

scatter_df = pd.DataFrame(scatter_data)

# 创建scatter plot，用于可视化
plt.figure(figsize=(12, 6))

# 为不同收入等级分配颜色
colors = {'低收入(8-12k)': '#ef4444', '中等收入(12-20k)': '#f59e0b', '高收入(20k+)': '#10b981'}

for income_level in ['低收入(8-12k)', '中等收入(12-20k)', '高收入(20k+)']:
    data = scatter_df[scatter_df['收入等级'] == income_level]
    plt.scatter(data['平均年龄'], data['违约率(%)'],
               label=income_level, color=colors[income_level], s=200, alpha=0.7)

plt.xlabel('年龄(岁)')
plt.ylabel('违约率(%)')
plt.title('不同年龄和收入群体的违约率分布')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# 输出数据给前端绘制
print(scatter_df.to_json())`,
  },

  'chart-2': {
    title: '逾期率趋势图',
    headers: ['时间', '逾期率(%)'],
    data: [
      { '时间': '2023年Q1', '逾期率(%)': 20 },
      { '时间': '2023年Q2', '逾期率(%)': 17.5 },
      { '时间': '2023年Q3', '逾期率(%)': 26.3 },
      { '时间': '2023年Q4', '逾期率(%)': 21 },
      { '时间': '2024年Q1', '逾期率(%)': 30 },
    ],
    totalRecords: 143000,
    type: 'chart',
    chartType: 'line',
    conclusion: `# 逾期率趋势分析图

展示贷款违约率随时间的变化趋势，可以清楚看到异常波动。

## 关键发现
- 2023年Q3和2024年Q1出现大幅恶化
- 最近的违约率达到30%，创新高
- 需要紧急调查原因

## 行动建议
需要对最近期的申请进行深入审查。`,
    code: `# 输入数据：compute-4（逾期率统计）

# 使用compute-4的时间序列数据生成折线图
import pandas as pd
import matplotlib.pyplot as plt

# 从compute-4获取的时间序列数据
timeline_data = {
    '时间': ['2023年Q1', '2023年Q2', '2023年Q3', '2023年Q4', '2024年Q1'],
    '逾期率(%)': [20, 17.5, 26.3, 21, 30]
}

timeline_df = pd.DataFrame(timeline_data)

# 创建折线图
plt.figure(figsize=(12, 6))
plt.plot(range(len(timeline_df)), timeline_df['逾期率(%)'],
         marker='o', linewidth=2, markersize=8, color='#ef4444', label='逾期率')

# 标记异常值
plt.axhline(y=timeline_df['逾期率(%)'].mean(), color='gray', linestyle='--', alpha=0.5, label='平均水平')

plt.xlabel('时间')
plt.ylabel('逾期率(%)')
plt.title('逾期率趋势图')
plt.xticks(range(len(timeline_df)), timeline_df['时间'], rotation=45)
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# 输出数据给前端绘制
print(timeline_df.to_json())`,
  },

  'chart-3': {
    title: '特征重要性柱状图',
    headers: ['特征', '重要性分数'],
    data: [
      { '特征': '职业类型', '重要性分数': 0.92 },
      { '特征': '申请金额', '重要性分数': 0.88 },
      { '特征': '申请时间', '重要性分数': 0.76 },
      { '特征': '年龄', '重要性分数': 0.68 },
      { '特征': '月收入', '重要性分数': 0.72 },
    ],
    totalRecords: 0,
    type: 'chart',
    chartType: 'bar',
    conclusion: `# 特征重要性排序柱状图

用柱状图清晰展示各个特征对违约预测的重要程度。

## 核心发现
1. **职业类型最重要**（0.92）- 最强预测器
2. **申请金额次之**（0.88）- 第二强预测器
3. **申请时间**（0.76）- 重要的环境因素

## 模型建议
应该优先在风控模型中使用这三个特征，可以快速构建有效的评分体系。`,
    code: `# 输入数据：compute-7（特征重要性排序）

# 使用compute-7的特征重要性数据生成柱状图
import pandas as pd
import matplotlib.pyplot as plt

# 从compute-7获取的特征重要性数据
importance_data = {
    '特征': ['职业类型', '申请金额', '申请时间/月份', '年龄', '月收入'],
    '重要性分数': [0.92, 0.88, 0.76, 0.68, 0.72]
}

importance_df = pd.DataFrame(importance_data).sort_values('重要性分数', ascending=True)

# 创建水平柱状图
plt.figure(figsize=(10, 6))
bars = plt.barh(importance_df['特征'], importance_df['重要性分数'], color='#8b5cf6')

# 为柱子着色（从浅到深）
for i, bar in enumerate(bars):
    if i < len(bars) // 3:
        bar.set_color('#10b981')  # 绿色 - 低重要性
    elif i < 2 * len(bars) // 3:
        bar.set_color('#f59e0b')  # 黄色 - 中重要性
    else:
        bar.set_color('#ef4444')  # 红色 - 高重要性

plt.xlabel('重要性分数(0-1)')
plt.title('特征重要性排序')
plt.xlim(0, 1)

# 在柱子上显示数值
for i, (idx, row) in enumerate(importance_df.iterrows()):
    plt.text(row['重要性分数'] + 0.02, i, f"{row['重要性分数']:.2f}",
            va='center', fontsize=10)

plt.tight_layout()
plt.show()

# 输出数据给前端绘制
print(importance_df.to_json())`,
  },

  // ===== Risk Model Feature Stability Project =====
  // ===== 数据源节点 =====
  'binning-train': {
    title: '训练集分箱结果',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'S001', '特征1': '[20, 30万)', '特征2': '[15, 20k)', '特征3': '[30, 40)', '特征4': '[1, 3)', '特征5': '[0, 1)', '特征6': '[1.4, 1.7)', '特征7': '[4, 8)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '是' },
      { '样本ID': 'S002', '特征1': '[10, 20万)', '特征2': '[10, 15k)', '特征3': '[20, 30)', '特征4': '[0, 1)', '特征5': '[0, 1)', '特征6': '[1.2, 1.4)', '特征7': '[2, 4)', '特征8': '[1, 2)', '特征9': '[0, 1)', '特征10': '[1, 2)', '好客户': '否' },
      { '样本ID': 'S003', '特征1': '[50万, ∞)', '特征2': '[30, 40k)', '特征3': '[40, 50)', '特征4': '[4, 6)', '特征5': '[0, 1)', '特征6': '[1.4, 1.7)', '特征7': '[8, 12)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[4, 6)', '好客户': '是' },
      { '样本ID': 'S004', '特征1': '[20, 30万)', '特征2': '[20, 30k)', '特征3': '[25, 35)', '特征4': '[2, 4)', '特征5': '[0, 1)', '特征6': '[0.8, 1.0)', '特征7': '[6, 8)', '特征8': '[3, 5)', '特征9': '[0, 1)', '特征10': '[1, 2)', '好客户': '是' },
      { '样本ID': 'S005', '特征1': '[20, 30万)', '特征2': '[15, 20k)', '特征3': '[35, 45)', '特征4': '[1, 3)', '特征5': '[0, 1)', '特征6': '[1.5, 1.8)', '特征7': '[4, 8)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '是' },
    ],
    totalRecords: 125432,
    type: 'table',
    code: `# 训练集分箱结果
import pandas as pd
import numpy as np

# 输入：data-train DataFrame
# 定义所有特征的分箱方案
binning_schemes = {
    '特征1': ([0, 10, 20, 30, 50, float('inf')], ['[0, 10万)', '[10, 20万)', '[20, 30万)', '[30, 50万)', '[50万, ∞)']),
    '特征2': ([0, 10, 15, 20, 30, float('inf')], ['[0, 10k)', '[10, 15k)', '[15, 20k)', '[20, 30k)', '[30k, ∞)']),
    '特征3': ([0, 20, 30, 40, 50, 100], ['[0, 20)', '[20, 30)', '[30, 40)', '[40, 50)', '[50, 100]']),
    # ... 其他特征的分箱方案
}

# 对所有特征进行分箱
for feature, (bins, labels) in binning_schemes.items():
    df[feature + '_binned'] = pd.cut(df[feature], bins=bins, labels=labels)

# 输出分箱结果
print(df[['sample_id', '特征1_binned', '特征2_binned', ..., '好客户']].head(5))`,
    conclusion: `# 训练集分箱计算结果

## 关键发现：零值分箱问题！

### 分箱分布情况
- **[0, 10万)**：样本28,450，坏客户6,140（占比21.6%）✓ 正常
- **[10, 20万)**：样本38,920，坏客户7,782（占比20.0%）✓ 正常
- **[20, 30万)**：样本32,180，坏客户6,356（占比19.8%）✓ 正常
- **[30, 50万)**：样本20,410，坏客户**0**（占比0.0%）⚠️ **零值！**
- **[50万, ∞)**：样本5,472，坏客户**0**（占比0.0%）⚠️ **零值！**

## 零值分箱的影响
2个分箱（占样本20.6%）中坏客户数为0，这导致：
1. IV计算中 WOE 无法正常计算（log(0)问题）
2. 特征的判别力被严重高估
3. 造成IV达到0.412的异常高值

## 原因分析
- 这些高额度用户可能存在审批标准变化
- 或者数据收集时间还不够长，坏账尚未完全暴露

## 建议
1. 添加平滑处理（Laplace平滑）处理零值
2. 重新检查审批逻辑
3. 考虑增加样本观察时间`,
  },

  'binning-val': {
    title: '验证集分箱结果',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'V001', '特征1': '[30, 50万)', '特征2': '[20, 30k)', '特征3': '[30, 40)', '特征4': '[0, 1)', '特征5': '[0, 1)', '特征6': '[1.5, 1.8)', '特征7': '[3, 4)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '是' },
      { '样本ID': 'V002', '特征1': '[10, 20万)', '特征2': '[10, 15k)', '特征3': '[20, 30)', '特征4': '[1, 3)', '特征5': '[0, 1)', '特征6': '[1.2, 1.4)', '特征7': '[2, 4)', '特征8': '[1, 2)', '特征9': '[0, 1)', '特征10': '[1, 2)', '好客户': '是' },
      { '样本ID': 'V003', '特征1': '[50万, ∞)', '特征2': '[30, 40k)', '特征3': '[40, 50)', '特征4': '[0, 1)', '特征5': '[0, 1)', '特征6': '[1.4, 1.7)', '特征7': '[6, 8)', '特征8': '[3, 5)', '特征9': '[0, 1)', '特征10': '[4, 6)', '好客户': '是' },
      { '样本ID': 'V004', '特征1': '[20, 30万)', '特征2': '[20, 30k)', '特征3': '[25, 35)', '特征4': '[2, 4)', '特征5': '[0, 1)', '特征6': '[0.8, 1.0)', '特征7': '[5, 6)', '特征8': '[3, 5)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '否' },
      { '样本ID': 'V005', '特征1': '[20, 30万)', '特征2': '[15, 20k)', '特征3': '[35, 45)', '特征4': '[1, 3)', '特征5': '[0, 1)', '特征6': '[1.5, 1.8)', '特征7': '[4, 8)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '是' },
    ],
    totalRecords: 31358,
    type: 'table',
    code: `# 验证集分箱结果
import pandas as pd

# 输入：data-val DataFrame
# 使用训练集相同的分箱方案进行分箱
binning_schemes = {
    '特征1': ([0, 10, 20, 30, 50, float('inf')], ['[0, 10万)', '[10, 20万)', '[20, 30万)', '[30, 50万)', '[50万, ∞)']),
    '特征2': ([0, 10, 15, 20, 30, float('inf')], ['[0, 10k)', '[10, 15k)', '[15, 20k)', '[20, 30k)', '[30k, ∞)']),
    '特征3': ([0, 20, 30, 40, 50, 100], ['[0, 20)', '[20, 30)', '[30, 40)', '[40, 50)', '[50, 100]']),
}

# 对所有特征进行分箱
for feature, (bins, labels) in binning_schemes.items():
    df[feature + '_binned'] = pd.cut(df[feature], bins=bins, labels=labels)

# 输出分箱结果
print(df[['sample_id', '特征1_binned', '特征2_binned', ..., '好客户']].head(5))`,
    conclusion: `# 验证集分箱与训练集对比

## 重要发现：验证集零值问题已改善！

### 分箱分布对比
- **[30, 50万)**：训练集坏客户0 → 验证集坏客户1,072（25.0%）
- **[50万, ∞)**：训练集坏客户0 → 验证集坏客户158（14.9%）

## 关键启示
验证集的分箱中**都有坏客户**，这说明：
1. **训练集问题不是总体规律** - 高额度贷款并非无风险
2. **训练集数据采集时间不足** - 样本的坏账还未完全暴露
3. **这是导致IV变异的主要原因** - 相同特征在不同时期的样本分布有本质差异

## 验证集IV结果
虽然分箱样本分布改变，但IV值反而下降到0.405，说明：
- 有足够的坏客户样本时，IV更稳定可靠
- 零值分箱导致的高IV值是虚假的`,
  },

  'binning-prod-2022': {
    title: '2022年分箱结果',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'P001', '特征1': '[20, 30万)', '特征2': '[15, 20k)', '特征3': '[30, 40)', '特征4': '[0, 1)', '特征5': '[0, 1)', '特征6': '[1.4, 1.7)', '特征7': '[4, 8)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '是' },
      { '样本ID': 'P002', '特征1': '[10, 20万)', '特征2': '[10, 15k)', '特征3': '[25, 35)', '特征4': '[1, 3)', '特征5': '[1, 3)', '特征6': '[1.4, 1.7)', '特征7': '[3, 4)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[1, 2)', '好客户': '否' },
      { '样本ID': 'P003', '特征1': '[50万, ∞)', '特征2': '[30, 40k)', '特征3': '[45, 50)', '特征4': '[0, 1)', '特征5': '[0, 1)', '特征6': '[1.3, 1.5)', '特征7': '[7, 8)', '特征8': '[3, 5)', '特征9': '[0, 1)', '特征10': '[4, 6)', '好客户': '是' },
      { '样本ID': 'P004', '特征1': '[20, 30万)', '特征2': '[20, 30k)', '特征3': '[28, 35)', '特征4': '[2, 4)', '特征5': '[0, 1)', '特征6': '[0.8, 1.0)', '特征7': '[5, 6)', '特征8': '[3, 5)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '是' },
      { '样本ID': 'P005', '特征1': '[30, 50万)', '特征2': '[15, 20k)', '特征3': '[35, 45)', '特征4': '[1, 3)', '特征5': '[0, 1)', '特征6': '[1.8, 2.0)', '特征7': '[4, 8)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '否' },
    ],
    totalRecords: 89543,
    type: 'table',
    code: `# 2022年分箱结果
import pandas as pd

# 输入：data-prod-2022 DataFrame
# 使用统一的分箱方案
binning_schemes = {
    '特征1': ([0, 10, 20, 30, 50, float('inf')], ['[0, 10万)', '[10, 20万)', '[20, 30万)', '[30, 50万)', '[50万, ∞)']),
    '特征2': ([0, 10, 15, 20, 30, float('inf')], ['[0, 10k)', '[10, 15k)', '[15, 20k)', '[20, 30k)', '[30k, ∞)']),
    '特征3': ([0, 20, 30, 40, 50, 100], ['[0, 20)', '[20, 30)', '[30, 40)', '[40, 50)', '[50, 100]']),
}

# 对所有特征进行分箱
for feature, (bins, labels) in binning_schemes.items():
    df[feature + '_binned'] = pd.cut(df[feature], bins=bins, labels=labels)

# 输出分箱结果
print(df[['sample_id', '特征1_binned', '特征2_binned', ..., '好客户']].head(5))`,
    conclusion: `# 2022年分箱结果 - 延续零值问题

### 分箱情况
- **[30, 50万)**：坏客户数为0（占样本16.1%）
- **[50万, ∞)**：坏客户数为0（占样本5.5%）
- **共21.6%的样本** 在零值分箱中

## 2022年IV=0.405的原因
虽然有零值分箱，但坏客户数全为0，无法计算WOE，导致：
1. IV计算采用平滑处理
2. 平滑后的IV反而低于训练集

## 一致性分析
- 与训练集相同的零值分箱位置
- 说明高额度贷款在生产环境中确实风险较低`,
  },

  'binning-prod-2023': {
    title: '2023年分箱结果',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'Q001', '特征1': '[20, 30万)', '特征2': '[20, 30k)', '特征3': '[30, 40)', '特征4': '[0, 1)', '特征5': '[0, 1)', '特征6': '[1.5, 1.8)', '特征7': '[4, 8)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '是' },
      { '样本ID': 'Q002', '特征1': '[10, 20万)', '特征2': '[10, 15k)', '特征3': '[25, 35)', '特征4': '[1, 3)', '特征5': '[0, 1)', '特征6': '[1.2, 1.4)', '特征7': '[3, 4)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[1, 2)', '好客户': '否' },
      { '样本ID': 'Q003', '特征1': '[50万, ∞)', '特征2': '[40, ∞)', '特征3': '[45, 50)', '特征4': '[0, 1)', '特征5': '[0, 1)', '特征6': '[1.3, 1.5)', '特征7': '[8, 12)', '特征8': '[3, 5)', '特征9': '[0, 1)', '特征10': '[4, 6)', '好客户': '是' },
      { '样本ID': 'Q004', '特征1': '[20, 30万)', '特征2': '[20, 30k)', '特征3': '[30, 40)', '特征4': '[2, 4)', '特征5': '[0, 1)', '特征6': '[0.9, 1.0)', '特征7': '[5, 6)', '特征8': '[3, 5)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '是' },
      { '样本ID': 'Q005', '特征1': '[30, 50万)', '特征2': '[15, 20k)', '特征3': '[35, 45)', '特征4': '[1, 3)', '特征5': '[0, 1)', '特征6': '[1.7, 1.9)', '特征7': '[4, 8)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '否' },
    ],
    totalRecords: 112687,
    type: 'table',
    code: `# 2023年分箱结果
import pandas as pd

# 输入：data-prod-2023 DataFrame
# 使用统一的分箱方案
binning_schemes = {
    '特征1': ([0, 10, 20, 30, 50, float('inf')], ['[0, 10万)', '[10, 20万)', '[20, 30万)', '[30, 50万)', '[50万, ∞)']),
    '特征2': ([0, 10, 15, 20, 30, float('inf')], ['[0, 10k)', '[10, 15k)', '[15, 20k)', '[20, 30k)', '[30k, ∞)']),
    '特征3': ([0, 20, 30, 40, 50, 100], ['[0, 20)', '[20, 30)', '[30, 40)', '[40, 50)', '[50, 100]']),
}

# 对所有特征进行分箱
for feature, (bins, labels) in binning_schemes.items():
    df[feature + '_binned'] = pd.cut(df[feature], bins=bins, labels=labels)

# 输出分箱结果
print(df[['sample_id', '特征1_binned', '特征2_binned', ..., '好客户']].head(5))`,
    conclusion: `# 2023年分箱结果 - 异常峰值的秘密！

### 分箱情况（关键发现）
- **[0, 30万)**：坏客户占比大幅上升到23-28%
- **[30, 50万)**：坏客户仅2人（占比0.01%）- **几乎为零！**
- **[50万, ∞)**：坏客户仅1人（占比0.01%）- **几乎为零！**

## IV=0.499异常峰值的真相！

### 数据变化
与2022年对比：
- [30, 50万)：样本从14,350增至17,650（23%增长）
- [50万, ∞)：样本从4,963增至9,053（82%激增）
- 但这些区间的坏客户数反而**极其稀少**

## 原因解释
1. **2023年审批标准改变** - 高额度贷款大幅增加
2. **但审批质量更严** - 这些高额度用户大多无违约
3. **特殊性** - 可能是:
   - 优质客户向高额度贷款转移
   - 或高额度产品的特殊审批规则
   - 或客观经济条件改善

## 结论
IV峰值不是模型变强，而是**样本分布异常变化**，导致分箱结构改变`,
  },

  'binning-prod-2024': {
    title: '2024年分箱结果',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'R001', '特征1': '[20, 30万)', '特征2': '[15, 20k)', '特征3': '[30, 40)', '特征4': '[0, 1)', '特征5': '[0, 1)', '特征6': '[1.5, 1.8)', '特征7': '[4, 8)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '是' },
      { '样本ID': 'R002', '特征1': '[10, 20万)', '特征2': '[10, 15k)', '特征3': '[20, 30)', '特征4': '[1, 3)', '特征5': '[1, 3)', '特征6': '[1.3, 1.5)', '特征7': '[3, 4)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[1, 2)', '好客户': '否' },
      { '样本ID': 'R003', '特征1': '[50万, ∞)', '特征2': '[40, ∞)', '特征3': '[50, 100]', '特征4': '[0, 1)', '特征5': '[0, 1)', '特征6': '[1.3, 1.5)', '特征7': '[8, 12)', '特征8': '[3, 5)', '特征9': '[0, 1)', '特征10': '[4, 6)', '好客户': '是' },
      { '样本ID': 'R004', '特征1': '[20, 30万)', '特征2': '[20, 30k)', '特征3': '[25, 35)', '特征4': '[2, 4)', '特征5': '[0, 1)', '特征6': '[0.8, 1.0)', '特征7': '[5, 6)', '特征8': '[3, 5)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '否' },
      { '样本ID': 'R005', '特征1': '[30, 50万)', '特征2': '[15, 20k)', '特征3': '[35, 45)', '特征4': '[1, 3)', '特征5': '[1, 3)', '特征6': '[1.8, 2.0)', '特征7': '[4, 8)', '特征8': '[2, 4)', '特征9': '[0, 1)', '特征10': '[2, 4)', '好客户': '否' },
    ],
    totalRecords: 98234,
    type: 'table',
    code: `# 2024年分箱结果
import pandas as pd

# 输入：data-prod-2024 DataFrame
# 使用统一的分箱方案
binning_schemes = {
    '特征1': ([0, 10, 20, 30, 50, float('inf')], ['[0, 10万)', '[10, 20万)', '[20, 30万)', '[30, 50万)', '[50万, ∞)']),
    '特征2': ([0, 10, 15, 20, 30, float('inf')], ['[0, 10k)', '[10, 15k)', '[15, 20k)', '[20, 30k)', '[30k, ∞)']),
    '特征3': ([0, 20, 30, 40, 50, 100], ['[0, 20)', '[20, 30)', '[30, 40)', '[40, 50)', '[50, 100]']),
}

# 对所有特征进行分箱
for feature, (bins, labels) in binning_schemes.items():
    df[feature + '_binned'] = pd.cut(df[feature], bins=bins, labels=labels)

# 输出分箱结果
print(df[['sample_id', '特征1_binned', '特征2_binned', ..., '好客户']].head(5))`,
    conclusion: `# 2024年分箱结果 - 回归异常前水平

### 分箱情况
- **[30, 50万)**：坏客户数再次回到0
- **[50万, ∞)**：坏客户数再次回到0
- **占样本24.5%** 的高额度贷款零坏客户

## IV=0.405的原因
与2022年一致，零值分箱导致计算异常

## 2023年异常的消退
2024年回归到2022年的模式，说明：
1. **2023年是真正的异常** - 只是一年的特殊现象
2. **可能原因**：
   - 审批政策调整只持续了一年
   - 高额度客户群体恢复到原有风险水平
   - 或经济形势改变影响了贷款质量

## 警示
- 2024年高额度贷款的零坏客户不一定是好信号
- 可能样本积累不足（数据截至10月）
- 需要继续监控下半年数据`,
  },

  'data-train': {
    title: '训练数据集',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'S001', '特征1': 28000, '特征2': 18000, '特征3': 32, '特征4': 2, '特征5': 0, '特征6': 1.56, '特征7': 5, '特征8': 3, '特征9': 0, '特征10': 2, '好客户': '是' },
      { '样本ID': 'S002', '特征1': 15000, '特征2': 12000, '特征3': 28, '特征4': 1, '特征5': 1, '特征6': 1.25, '特征7': 2, '特征8': 1, '特征9': 1, '特征10': 1, '好客户': '否' },
      { '样本ID': 'S003', '特征1': 50000, '特征2': 35000, '特征3': 45, '特征4': 5, '特征5': 0, '特征6': 1.43, '特征7': 8, '特征8': 2, '特征9': 0, '特征10': 4, '好客户': '是' },
      { '样本ID': 'S004', '特征1': 20000, '特征2': 22000, '特征3': 29, '特征4': 3, '特征5': 0, '特征6': 0.91, '特征7': 6, '特征8': 4, '特征9': 0, '特征10': 1, '好客户': '是' },
      { '样本ID': 'S005', '特征1': 25000, '特征2': 15000, '特征3': 35, '特征4': 2, '特征5': 2, '特征6': 1.67, '特征7': 3, '特征8': 2, '特征9': 2, '特征10': 3, '好客户': '否' },
    ],
    totalRecords: 125432,
    type: 'table',
    code: `SELECT
  sample_id,
  loan_amount as 申请金额,
  monthly_income as 月收入,
  age as 年龄,
  occupation as 职业,
  default_count as 逾期次数,
  CASE WHEN target = 1 THEN '是' ELSE '否' END as 好客户
FROM train_dataset
WHERE date_range BETWEEN '2020-01' AND '2021-12'
LIMIT 5;`,
    conclusion: `# 训练数据集

## 数据规模
- **总样本数**：125,432 条
- **特征维度**：118 个（包括衍生特征）
- **时间跨度**：2020年1月 - 2021年12月
- **好客户占比**：75.3%（94,550条 ÷ 125,432条）

## 原始特征示例
表格展示的是部分原始样本数据，包含：
- **申请金额**：用户申请的贷款金额（万元）
- **月收入**：申请人的月收入（元）
- **年龄**：申请人年龄
- **职业**：职业分类（118个特征由此衍生）
- **逾期次数**：历史逾期次数
- **好客户标签**：目标变量（是/否）

## 数据质量
- 缺失值率：0.2%
- 异常值处理：已清洗
- 去重率：100%

## 后续处理
- 这些原始特征值会在分箱步骤中转换为分箱类别
- 118个特征中，申请金额衍生特征的稳定性最差`,
  },

  'data-val': {
    title: '验证数据集',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'V001', '特征1': 32000, '特征2': 20000, '特征3': 35, '特征4': 1, '特征5': 0, '特征6': 1.60, '特征7': 3, '特征8': 2, '特征9': 1, '特征10': 3, '好客户': '是' },
      { '样本ID': 'V002', '特征1': 18000, '特征2': 14000, '特征3': 26, '特征4': 2, '特征5': 0, '特征6': 1.29, '特征7': 2, '特征8': 1, '特征9': 0, '特征10': 1, '好客户': '是' },
      { '样本ID': 'V003', '特征1': 48000, '特征2': 32000, '特征3': 42, '特征4': 1, '特征5': 0, '特征6': 1.50, '特征7': 6, '特征8': 3, '特征9': 1, '特征10': 4, '好客户': '是' },
      { '样本ID': 'V004', '特征1': 22000, '特征2': 24000, '特征3': 31, '特征4': 3, '特征5': 1, '特征6': 0.92, '特征7': 5, '特征8': 3, '特征9': 1, '特征10': 2, '好客户': '否' },
      { '样本ID': 'V005', '特征1': 27000, '特征2': 17000, '特征3': 38, '特征4': 2, '特征5': 0, '特征6': 1.59, '特征7': 4, '特征8': 2, '特征9': 0, '特征10': 2, '好客户': '是' },
    ],
    totalRecords: 31358,
    type: 'table',
    code: `SELECT
  sample_id,
  feature_1,
  feature_2,
  feature_3,
  feature_4,
  feature_5,
  feature_6,
  feature_7,
  feature_8,
  feature_9,
  feature_10,
  CASE WHEN target = 1 THEN '是' ELSE '否' END as 好客户
FROM validation_dataset
WHERE date_range BETWEEN '2022-01' AND '2022-06'
LIMIT 5;`,
    conclusion: `# 验证数据集

## 数据规模
- **总样本数**：31,358 条（训练集的25%）
- **特征维度**：118 个（与训练集完全一致）
- **时间跨度**：2022年1月 - 2022年6月
- **好客户占比**：74.8%（23,436条 ÷ 31,358条）

## 原始特征示例
表格展示验证集的部分样本，特征定义与训练集相同

## 与训练集对比
- **好客户占比差异**：74.8% vs 75.3%（差异0.5%）
- **特征定义**：完全一致，确保训练和验证的一致性
- **作用**：用于评估模型的泛化能力`,
  },

  'data-prod-2022': {
    title: '2022年生产数据',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'P001', '特征1': 26000, '特征2': 17500, '特征3': 33, '特征4': 1, '特征5': 0, '特征6': 1.49, '特征7': 4, '特征8': 2, '特征9': 0, '特征10': 2, '好客户': '是' },
      { '样本ID': 'P002', '特征1': 16000, '特征2': 11000, '特征3': 27, '特征4': 2, '特征5': 2, '特征6': 1.45, '特征7': 3, '特征8': 2, '特征9': 1, '特征10': 1, '好客户': '否' },
      { '样本ID': 'P003', '特征1': 52000, '特征2': 38000, '特征3': 48, '特征4': 1, '特征5': 0, '特征6': 1.37, '特征7': 7, '特征8': 3, '特征9': 0, '特征10': 5, '好客户': '是' },
      { '样本ID': 'P004', '特征1': 19000, '特征2': 21000, '特征3': 30, '特征4': 3, '特征5': 0, '特征6': 0.90, '特征7': 5, '特征8': 3, '特征9': 0, '特征10': 2, '好客户': '是' },
      { '样本ID': 'P005', '特征1': 30000, '特征2': 16000, '特征3': 36, '特征4': 2, '特征5': 1, '特征6': 1.88, '特征7': 4, '特征8': 2, '特征9': 0, '特征10': 2, '好客户': '否' },
    ],
    totalRecords: 89543,
    type: 'table',
    code: `SELECT
  sample_id,
  feature_1,
  feature_2,
  feature_3,
  feature_4,
  feature_5,
  feature_6,
  feature_7,
  feature_8,
  feature_9,
  feature_10,
  CASE WHEN repayment_status = 'good' THEN '是' ELSE '否' END as 好客户
FROM production_data
WHERE YEAR(application_date) = 2022
LIMIT 5;`,
    conclusion: `# 2022年生产数据

## 数据规模
- **样本数**：89,543 条（完整年度）
- **特征维度**：118 个（与训练集相同）
- **好客户占比**：73.1%（65,445条 ÷ 89,543条）

## 原始特征示例
表格展示2022年生产数据的部分样本

## 与训练集对比
- **好客户占比变化**：75.3% → 73.1%（下降2.2个百分点）
- **可能原因**：
  - 2022年经济环境变化
  - 审批标准调整
  - 客户群体结构变化`,
  },

  'data-prod-2023': {
    title: '2023年生产数据',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'Q001', '特征1': 29000, '特征2': 19000, '特征3': 34, '特征4': 1, '特征5': 0, '特征6': 1.53, '特征7': 4, '特征8': 2, '特征9': 1, '特征10': 3, '好客户': '是' },
      { '样本ID': 'Q002', '特征1': 17000, '特征2': 13000, '特征3': 28, '特征4': 2, '特征5': 1, '特征6': 1.31, '特征7': 3, '特征8': 2, '特征9': 0, '特征10': 1, '好客户': '否' },
      { '样本ID': 'Q003', '特征1': 55000, '特征2': 40000, '特征3': 50, '特征4': 1, '特征5': 0, '特征6': 1.38, '特征7': 7, '特征8': 3, '特征9': 1, '特征10': 5, '好客户': '是' },
      { '样本ID': 'Q004', '特征1': 21000, '特征2': 23000, '特征3': 32, '特征4': 3, '特征5': 0, '特征6': 0.91, '特征7': 5, '特征8': 3, '特征9': 0, '特征10': 2, '好客户': '是' },
      { '样本ID': 'Q005', '特征1': 32000, '特征2': 18000, '特征3': 37, '特征4': 2, '特征5': 1, '特征6': 1.78, '特征7': 4, '特征8': 2, '特征9': 1, '特征10': 2, '好客户': '否' },
    ],
    totalRecords: 112687,
    type: 'table',
    code: `SELECT
  sample_id,
  feature_1,
  feature_2,
  feature_3,
  feature_4,
  feature_5,
  feature_6,
  feature_7,
  feature_8,
  feature_9,
  feature_10,
  CASE WHEN repayment_status = 'good' THEN '是' ELSE '否' END as 好客户
FROM production_data
WHERE YEAR(application_date) = 2023
LIMIT 5;`,
    conclusion: `# 2023年生产数据

## 数据规模
- **样本数**：112,687 条（完整年度）
- **特征维度**：118 个（与训练集相同）
- **好客户占比**：72.8%（82,073条 ÷ 112,687条）

## 原始特征示例
表格展示2023年生产数据的部分样本

## 与前年对比
- **好客户占比变化**：73.1% → 72.8%（下降0.3个百分点）
- **整体稳定**：虽然样本量增长，但质量保持稳定`,
  },

  'data-prod-2024': {
    title: '2024年生产数据',
    headers: ['样本ID', '特征1', '特征2', '特征3', '特征4', '特征5', '特征6', '特征7', '特征8', '特征9', '特征10', '好客户'],
    data: [
      { '样本ID': 'R001', '特征1': 25000, '特征2': 16000, '特征3': 31, '特征4': 1, '特征5': 0, '特征6': 1.56, '特征7': 4, '特征8': 2, '特征9': 0, '特征10': 2, '好客户': '是' },
      { '样本ID': 'R002', '特征1': 14000, '特征2': 10000, '特征3': 25, '特征4': 2, '特征5': 2, '特征6': 1.40, '特征7': 3, '特征8': 2, '特征9': 1, '特征10': 1, '好客户': '否' },
      { '样本ID': 'R003', '特征1': 58000, '特征2': 42000, '特征3': 52, '特征4': 1, '特征5': 0, '特征6': 1.38, '特征7': 8, '特征8': 4, '特征9': 0, '特征10': 5, '好客户': '是' },
      { '样本ID': 'R004', '特征1': 18000, '特征2': 20000, '特征3': 28, '特征4': 3, '特征5': 1, '特征6': 0.90, '特征7': 5, '特征8': 3, '特征9': 0, '特征10': 2, '好客户': '否' },
      { '样本ID': 'R005', '特征1': 35000, '特征2': 19000, '特征3': 39, '特征4': 2, '特征5': 2, '特征6': 1.84, '特征7': 4, '特征8': 2, '特征9': 1, '特征10': 2, '好客户': '否' },
    ],
    totalRecords: 98234,
    type: 'table',
    code: `SELECT
  sample_id,
  feature_1,
  feature_2,
  feature_3,
  feature_4,
  feature_5,
  feature_6,
  feature_7,
  feature_8,
  feature_9,
  feature_10,
  CASE WHEN repayment_status = 'good' THEN '是' ELSE '否' END as 好客户
FROM production_data
WHERE YEAR(application_date) = 2024
LIMIT 5;`,
    conclusion: `# 2024年生产数据（截至10月）

## 数据规模
- **样本数**：98,234 条（2024年1月-10月）
- **特征维度**：118 个（与训练集相同）
- **好客户占比**：71.5%（70,217条 ÷ 98,234条）

## 原始特征示例
表格展示2024年生产数据的部分样本

## 与前年对比
- **好客户占比变化**：72.8% → 71.5%（下降1.3个百分点）
- **质量恶化**：需要关注最近审批标准变化
- **观测期不足**：数据仅至10月，待完整年度数据`,
  },

  // ===== 计算节点 =====
  'compute-iv': {
    title: 'IV计算（特征稳定性评估）',
    headers: ['特征名称', '训练集IV', '验证集IV', '2022年IV', '2023年IV', '2024年IV'],
    data: [
      { '特征名称': '申请金额衍生', '训练集IV': 0.412, '验证集IV': 0.405, '2022年IV': 0.412, '2023年IV': 0.499, '2024年IV': 0.405 },
      { '特征名称': '收入-债务比', '训练集IV': 0.368, '验证集IV': 0.362, '2022年IV': 0.368, '2023年IV': 0.365, '2024年IV': 0.359 },
      { '特征名称': '年龄分段组合', '训练集IV': 0.342, '验证集IV': 0.338, '2022年IV': 0.342, '2023年IV': 0.338, '2024年IV': 0.329 },
      { '特征名称': '职业类型编码', '训练集IV': 0.295, '验证集IV': 0.288, '2022年IV': 0.295, '2023年IV': 0.292, '2024年IV': 0.288 },
      { '特征名称': '逾期历史次数', '训练集IV': 0.268, '验证集IV': 0.261, '2022年IV': 0.268, '2023年IV': 0.265, '2024年IV': 0.261 },
    ],
    totalRecords: 118,
    type: 'table',
    code: `import pandas as pd
import numpy as np

# 输入：各数据集的分箱结果DataFrames
# binning_train, binning_val, binning_prod_2022, binning_prod_2023, binning_prod_2024

def calculate_iv(binned_data, target_col):
    """计算单个特征的IV值"""
    # 统计各分箱的好坏客户数
    agg_data = binned_data.groupby('bin').agg({
        target_col: ['sum', 'count']
    })

    # 计算WOE和IV
    good_count = agg_data[(target_col, 'sum')]
    bad_count = agg_data[(target_col, 'count')] - good_count
    total_good = good_count.sum()
    total_bad = bad_count.sum()

    pct_good = good_count / total_good
    pct_bad = bad_count / total_bad

    woe = np.log(pct_good / pct_bad)
    iv = ((pct_good - pct_bad) * woe).sum()

    return iv

# 为每个数据集计算所有特征的IV
result = pd.DataFrame()
for dataset_name, binned_df in [
    ('train', binning_train),
    ('val', binning_val),
    ('2022', binning_prod_2022),
    ('2023', binning_prod_2023),
    ('2024', binning_prod_2024)
]:
    iv_values = {}
    for feature in features:
        iv_values[feature] = calculate_iv(binned_df, feature)
    result[dataset_name] = iv_values

print(result)`,
    conclusion: `# IV计算结果

## 计算方法
1. **输入**：各数据集的分箱结果（来自binning节点）
2. **计算流程**：
   - 统计各分箱的好坏客户数
   - 计算WOE（Weight of Evidence）：ln(好客户占比 / 坏客户占比)
   - 计算IV（Information Value）：Σ(好坏占比差 × WOE)
3. **输出**：118个特征在5个数据集上的IV值

## 关键观察
- **申请金额衍生**：
  - 训练集：0.412
  - 验证集：0.405（泛化良好）
  - 2022年：0.412（稳定）
  - 2023年：0.499（异常峰值！）
  - 2024年：0.405（回归）
- **其他特征**：相对稳定，逐年下降趋势

## 异常发现
2023年申请金额IV峰值（0.499）说明该年份的分箱分布存在特殊变化`,
  },

  'compute-iv-diff': {
    title: 'IV差值计算',
    headers: ['特征名称', '训练集-2022差值', '训练集-2023差值', '训练集-2024差值', '平均差值'],
    data: [
      { '特征名称': '申请金额衍生', '训练集-2022差值': 0.000, '训练集-2023差值': 0.087, '训练集-2024差值': 0.007, '平均差值': 0.031 },
      { '特征名称': '收入-债务比', '训练集-2022差值': 0.000, '训练集-2023差值': 0.003, '训练集-2024差值': 0.009, '平均差值': 0.004 },
      { '特征名称': '年龄分段组合', '训练集-2022差值': 0.000, '训练集-2023差值': 0.004, '训练集-2024差值': 0.013, '平均差值': 0.006 },
      { '特征名称': '职业类型编码', '训练集-2022差值': 0.000, '训练集-2023差值': 0.003, '训练集-2024差值': 0.007, '平均差值': 0.003 },
      { '特征名称': '逾期历史次数', '训练集-2022差值': 0.000, '训练集-2023差值': 0.003, '训练集-2024差值': 0.007, '平均差值': 0.003 },
    ],
    totalRecords: 118,
    type: 'table',
    code: `import pandas as pd
import numpy as np

# 输入：各数据集的IV计算结果DataFrames
# iv_train, iv_val, iv_prod_2022, iv_prod_2023, iv_prod_2024

def calculate_iv_diff(iv_train, iv_prod):
    """计算IV差值"""
    diff = abs(iv_train - iv_prod)
    return diff.round(3)

# 计算各生产数据集与训练集的IV差值
diff_2022 = calculate_iv_diff(iv_train, iv_prod_2022)
diff_2023 = calculate_iv_diff(iv_train, iv_prod_2023)
diff_2024 = calculate_iv_diff(iv_train, iv_prod_2024)

# 构建结果DataFrame
result = pd.DataFrame({
    '特征名称': iv_train['特征名称'],
    '训练集-2022差值': diff_2022,
    '训练集-2023差值': diff_2023,
    '训练集-2024差值': diff_2024,
    '平均差值': (diff_2022 + diff_2023 + diff_2024) / 3
})

print(result)`,
    conclusion: `# IV差值分析

## 跨年份对比
- **2022年**：平均差值0.019（基准年度）
- **2023年**：平均差值0.014（最稳定，差异最小）
- **2024年**：平均差值0.021（波动增大，需要关注）

## 特征稳定性分类
- **高风险**（差值>0.05）：12个特征
- **低风险**（差值0.01-0.03）：64个特征
- **极低风险**（差值<0.01）：42个特征

## 三年均值：0.018 - 整体保持稳定`,
  },

  'compute-feature-rank': {
    title: '特征差异排序',
    headers: ['排名', '特征名称', '三年平均差值'],
    data: [
      { '排名': 1, '特征名称': '申请金额衍生', '三年平均差值': 0.087 },
      { '排名': 2, '特征名称': '收入-债务比', '三年平均差值': 0.076 },
      { '排名': 3, '特征名称': '年龄分段组合', '三年平均差值': 0.069 },
      { '排名': 4, '特征名称': '职业类型编码', '三年平均差值': 0.032 },
      { '排名': 5, '特征名称': '逾期历史次数', '三年平均差值': 0.028 },
    ],
    totalRecords: 118,
    type: 'table',
    code: `SELECT
  ROW_NUMBER() OVER (ORDER BY 平均差值 DESC) as 排名,
  特征名称,
  平均差值
FROM 特征差异表
ORDER BY 平均差值 DESC
LIMIT 5;`,
    conclusion: `# 特征差异排序

## 高风险特征（Top 3）
1. **申请金额衍生**（差值0.087）
2. **收入-债务比**（差值0.076）
3. **年龄分段组合**（差值0.069）

## 不稳定性原因分析
- **申请金额衍生**：金额分段阈值自动调整、经济周期影响、产品策略变化
- **收入-债务比**：收入统计口径变化、债务定义更新
- **年龄分段组合**：客户年龄结构变化、风险偏好调整

## 建议行动
- 立即审查这三个特征的定义和计算逻辑
- 考虑重新建模或调整权重`,
  },

  'compute-max-feature': {
    title: '最不稳定特征识别',
    headers: ['特征名称', '2022年IV', '2023年IV', '2024年IV', '波动范围'],
    data: [
      { '特征名称': '申请金额衍生', '2022年IV': 0.412, '2023年IV': 0.499, '2024年IV': 0.405, '波动范围': '0.094' },
      { '特征名称': '收入-债务比', '2022年IV': 0.368, '2023年IV': 0.365, '2024年IV': 0.359, '波动范围': '0.009' },
      { '特征名称': '年龄分段组合', '2022年IV': 0.342, '2023年IV': 0.338, '2024年IV': 0.329, '波动范围': '0.013' },
    ],
    totalRecords: 118,
    type: 'table',
    code: `# 最不稳定特征识别
import pandas as pd

# 输入：compute-iv-diff 的结果 DataFrame
# 计算每个特征的波动范围
df['波动范围'] = df[['IV_2022', 'IV_2023', 'IV_2024']].max(axis=1) - df[['IV_2022', 'IV_2023', 'IV_2024']].min(axis=1)

# 排序并输出Top特征
top_unstable = df.nlargest(10, '波动范围')[['特征名称', 'IV_2022', 'IV_2023', 'IV_2024', '波动范围']]

print(top_unstable)
print(f"\\n最不稳定特征: {top_unstable.iloc[0]['特征名称']}, 波动范围: {top_unstable.iloc[0]['波动范围']:.4f}")`,
    conclusion: `# 最不稳定特征

## 第一名：申请金额衍生
- **2022年**：IV = 0.412
- **2023年**：IV = 0.499（峰值）
- **2024年**：IV = 0.405
- **波动幅度**：0.094（最高）
- **平均差值**：0.087`,
  },

  'chart-iv-scatter': {
    title: 'IV分布散点图',
    headers: ['特征名称', '数据集', 'IV值'],
    data: [
      { '特征名称': '申请金额衍生', '数据集': '训练集', 'IV值': 0.412 },
      { '特征名称': '申请金额衍生', '数据集': '验证集', 'IV值': 0.405 },
      { '特征名称': '申请金额衍生', '数据集': '2022年', 'IV值': 0.412 },
      { '特征名称': '申请金额衍生', '数据集': '2023年', 'IV值': 0.499 },
      { '特征名称': '申请金额衍生', '数据集': '2024年', 'IV值': 0.405 },
      { '特征名称': '收入-债务比', '数据集': '训练集', 'IV值': 0.368 },
      { '特征名称': '收入-债务比', '数据集': '验证集', 'IV值': 0.362 },
      { '特征名称': '收入-债务比', '数据集': '2022年', 'IV值': 0.368 },
      { '特征名称': '收入-债务比', '数据集': '2023年', 'IV值': 0.365 },
      { '特征名称': '收入-债务比', '数据集': '2024年', 'IV值': 0.359 },
      { '特征名称': '年龄分段组合', '数据集': '训练集', 'IV值': 0.342 },
      { '特征名称': '年龄分段组合', '数据集': '验证集', 'IV值': 0.338 },
      { '特征名称': '年龄分段组合', '数据集': '2022年', 'IV值': 0.342 },
      { '特征名称': '年龄分段组合', '数据集': '2023年', 'IV值': 0.338 },
      { '特征名称': '年龄分段组合', '数据集': '2024年', 'IV值': 0.329 },
      { '特征名称': '职业类型编码', '数据集': '训练集', 'IV值': 0.295 },
      { '特征名称': '职业类型编码', '数据集': '验证集', 'IV值': 0.288 },
      { '特征名称': '职业类型编码', '数据集': '2022年', 'IV值': 0.295 },
      { '特征名称': '职业类型编码', '数据集': '2023年', 'IV值': 0.292 },
      { '特征名称': '职业类型编码', '数据集': '2024年', 'IV值': 0.288 },
      { '特征名称': '逾期历史次数', '数据集': '训练集', 'IV值': 0.268 },
      { '特征名称': '逾期历史次数', '数据集': '验证集', 'IV值': 0.261 },
      { '特征名称': '逾期历史次数', '数据集': '2022年', 'IV值': 0.268 },
      { '特征名称': '逾期历史次数', '数据集': '2023年', 'IV值': 0.265 },
      { '特征名称': '逾期历史次数', '数据集': '2024年', 'IV值': 0.261 },
    ],
    totalRecords: 118,
    type: 'chart',
    chartType: 'scatter',
    code: `# IV分布散点图
import pandas as pd
import matplotlib.pyplot as plt

# 输入：5个关键特征在5个数据集上的IV数据
# 绘制散点图展示特征IV在不同数据集的分布

fig, ax = plt.subplots(figsize=(12, 6))

# 定义特征和颜色
features = ['申请金额衍生', '收入-债务比', '年龄分段组合', '职业类型编码', '逾期历史次数']
datasets = ['训练集', '验证集', '2022年', '2023年', '2024年']
colors = ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6']

# 为每个特征和数据集创建散点
for dataset_idx, (dataset, color) in enumerate(zip(datasets, colors)):
    feature_indices = []
    iv_values = []

    for feat_idx, feature in enumerate(features):
        # 从数据中获取该特征在该数据集的IV值
        iv = df[(df['特征名称'] == feature) & (df['数据集'] == dataset)]['IV值'].values[0]

        # 在特征组内添加数据集偏移
        x_offset = (dataset_idx - 2) * 0.08
        feature_indices.append(feat_idx + x_offset)
        iv_values.append(iv)

    ax.scatter(feature_indices, iv_values, color=color, label=dataset, s=100, alpha=0.7)

# 设置坐标轴
ax.set_xticks(range(len(features)))
ax.set_xticklabels(features, rotation=45, ha='right')
ax.set_ylabel('IV值')
ax.set_title('特征IV值在不同数据集的分布')
ax.legend(title='数据集', bbox_to_anchor=(1.05, 1), loc='upper left')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()`,
    conclusion: `# IV分布散点图分析

## 数据概览
展示5个关键特征在5个数据集上的IV值分布：
- **申请金额衍生**：训练集0.412 → 验证集0.405 → 2022年0.412 → 2023年0.499 → 2024年0.405
- **收入-债务比**：训练集0.368 → 验证集0.362 → 2022年0.368 → 2023年0.365 → 2024年0.359
- **年龄分段组合**：训练集0.342 → 验证集0.338 → 2022年0.342 → 2023年0.338 → 2024年0.329
- **职业类型编码**：训练集0.295 → 验证集0.288 → 2022年0.295 → 2023年0.292 → 2024年0.288
- **逾期历史次数**：训练集0.268 → 验证集0.261 → 2022年0.268 → 2023年0.265 → 2024年0.261

## 关键观察

### 1. 特征稳定性排序
- **申请金额衍生**：异常离群，2023年峰值(0.499)最为突出
- **收入-债务比**：次高，相对稳定，波动范围0.359-0.368
- **年龄分段组合**：中等，逐年下降，范围0.329-0.342
- **职业类型编码**：较低，波动最小，范围0.288-0.295
- **逾期历史次数**：最低，稳定性最好，范围0.261-0.268

### 2. 验证集泛化性
训练集和验证集IV高度相关，验证集普遍略低于训练集（平均差异0.007），说明模型泛化能力好。

### 3. 时间序列异常
- **2023年峰值**：申请金额衍生达0.499，为其他年份的明显异常
- **恢复趋势**：2024年回归到0.405，接近训练集水平
- **其他特征**：整体呈下降趋势，表明模型整体泛化能力在衰退`,
  },

  'chart-diff-scatter': {
    title: 'IV差值散点图',
    headers: ['特征名称', '数据集', '差值'],
    data: [
      { '特征名称': '申请金额衍生', '数据集': '2022年', '差值': 0.019 },
      { '特征名称': '申请金额衍生', '数据集': '2023年', '差值': 0.076 },
      { '特征名称': '申请金额衍生', '数据集': '2024年', '差值': 0.021 },
      { '特征名称': '收入-债务比', '数据集': '2022年', '差值': 0.003 },
      { '特征名称': '收入-债务比', '数据集': '2023年', '差值': 0.002 },
      { '特征名称': '收入-债务比', '数据集': '2024年', '差值': 0.009 },
      { '特征名称': '年龄分段组合', '数据集': '2022年', '差值': 0.000 },
      { '特征名称': '年龄分段组合', '数据集': '2023年', '差值': 0.004 },
      { '特征名称': '年龄分段组合', '数据集': '2024年', '差值': 0.013 },
      { '特征名称': '职业类型编码', '数据集': '2022年', '差值': 0.000 },
      { '特征名称': '职业类型编码', '数据集': '2023年', '差值': 0.003 },
      { '特征名称': '职业类型编码', '数据集': '2024年', '差值': 0.007 },
      { '特征名称': '逾期历史次数', '数据集': '2022年', '差值': 0.000 },
      { '特征名称': '逾期历史次数', '数据集': '2023年', '差值': 0.003 },
      { '特征名称': '逾期历史次数', '数据集': '2024年', '差值': 0.007 },
    ],
    totalRecords: 118,
    type: 'chart',
    chartType: 'scatter',
    code: `# IV差值散点图 - 与训练集对比
import pandas as pd
import matplotlib.pyplot as plt

# 输入：5个关键特征在生产数据集上与训练集的IV差值
# 绘制不同年份与训练集的差值散点图

fig, ax = plt.subplots(figsize=(12, 6))

# 定义特征和颜色
features = ['申请金额衍生', '收入-债务比', '年龄分段组合', '职业类型编码', '逾期历史次数']
years = ['2022年', '2023年', '2024年']
colors = ['#10b981', '#3b82f6', '#8b5cf6']

# 为每个年份创建散点
for year_idx, (year, color) in enumerate(zip(years, colors)):
    feature_indices = []
    diff_values = []

    for feat_idx, feature in enumerate(features):
        # 从数据中获取该特征与训练集的差值
        diff = df[(df['特征名称'] == feature) & (df['数据集'] == year)]['差值'].values[0]

        # 在特征组内添加年份偏移
        x_offset = (year_idx - 1) * 0.08
        feature_indices.append(feat_idx + x_offset)
        diff_values.append(diff)

    ax.scatter(feature_indices, diff_values, color=color, label=f'{year} vs 训练集', s=100, alpha=0.7)

# 设置坐标轴
ax.set_xticks(range(len(features)))
ax.set_xticklabels(features, rotation=45, ha='right')
ax.set_ylabel('IV差值')
ax.set_title('生产数据集相对训练集的IV差值分布')
ax.legend(title='数据集对比', bbox_to_anchor=(1.05, 1), loc='upper left')
ax.grid(True, alpha=0.3)
ax.axhline(y=0, color='gray', linestyle='--', alpha=0.5)

plt.tight_layout()
plt.show()`,
    conclusion: `# IV差值散点图分析 - 与训练集对比

## 数据概览
展示5个关键特征相对训练集的IV差值：

| 特征 | 2022年差值 | 2023年差值 | 2024年差值 |
|------|-----------|-----------|-----------|
| 申请金额衍生 | 0.000 | 0.087 | 0.007 |
| 收入-债务比 | 0.000 | 0.003 | 0.009 |
| 年龄分段组合 | 0.000 | 0.004 | 0.013 |
| 职业类型编码 | 0.000 | 0.003 | 0.007 |
| 逾期历史次数 | 0.000 | 0.003 | 0.007 |

## 关键观察

### 1. 申请金额异常突出
- **2022年**：差值0.000（完全一致）
- **2023年**：差值0.087（**峰值！最大异常**）
- **2024年**：差值0.007（迅速恢复）
- **模式**：尖峰异常，前后恢复正常

### 2. 其他特征稳定演变
- **收入-债务比**：0.000 → 0.003 → 0.009（缓慢上升）
- **年龄分段组合**：0.000 → 0.004 → 0.013（加速上升）
- **职业类型编码**：0.000 → 0.003 → 0.007（稳定上升）
- **逾期历史次数**：0.000 → 0.003 → 0.007（稳定上升）
- **模式**：逐年增加，表示逐步偏离训练集特性

### 3. 稳定性分析
- **2022年最稳定**：所有特征与训练集完全一致
- **2023年出现波动**：申请金额异常，其他特征小幅增加
- **2024年加速偏离**：除申请金额外，其他特征差值继续增加`,
  },

  'compute-binning': {
    title: '申请金额分箱计算',
    headers: ['分箱', '下界(万)', '上界(万)', '数据集', '好客户数', '坏客户数'],
    data: [
      { '分箱': '[0, 10万)', '下界(万)': 0, '上界(万)': 10, '数据集': '训练集', '好客户数': 22310, '坏客户数': 6140 },
      { '分箱': '[0, 10万)', '下界(万)': 0, '上界(万)': 10, '数据集': '验证集', '好客户数': 5706, '坏客户数': 1444 },
      { '分箱': '[0, 10万)', '下界(万)': 0, '上界(万)': 10, '数据集': '2022年', '好客户数': 15012, '坏客户数': 4222 },
      { '分箱': '[0, 10万)', '下界(万)': 0, '上界(万)': 10, '数据集': '2023年', '好客户数': 18710, '坏客户数': 5860 },
      { '分箱': '[0, 10万)', '下界(万)': 0, '上界(万)': 10, '数据集': '2024年', '好客户数': 15880, '坏客户数': 5460 },
      { '分箱': '[10, 20万)', '下界(万)': 10, '上界(万)': 20, '数据集': '训练集', '好客户数': 31138, '坏客户数': 7782 },
      { '分箱': '[10, 20万)', '下界(万)': 10, '上界(万)': 20, '数据集': '验证集', '好客户数': 8172, '坏客户数': 2043 },
      { '分箱': '[10, 20万)', '下界(万)': 10, '上界(万)': 20, '数据集': '2022年', '好客户数': 21425, '坏客户数': 5731 },
      { '分箱': '[10, 20万)', '下界(万)': 10, '上界(万)': 20, '数据集': '2023年', '好客户数': 24598, '坏客户数': 7852 },
      { '分箱': '[10, 20万)', '下界(万)': 10, '上界(万)': 20, '数据集': '2024年', '好客户数': 19761, '坏客户数': 8469 },
      { '分箱': '[20, 30万)', '下界(万)': 20, '上界(万)': 30, '数据集': '训练集', '好客户数': 25824, '坏客户数': 6356 },
      { '分箱': '[20, 30万)', '下界(万)': 20, '上界(万)': 30, '数据集': '验证集', '好客户数': 6903, '坏客户数': 1747 },
      { '分箱': '[20, 30万)', '下界(万)': 20, '上界(万)': 30, '数据集': '2022年', '好客户数': 18876, '坏客户数': 4964 },
      { '分箱': '[20, 30万)', '下界(万)': 20, '上界(万)': 30, '数据集': '2023年', '好客户数': 20675, '坏客户数': 8289 },
      { '分箱': '[20, 30万)', '下界(万)': 20, '上界(万)': 30, '数据集': '2024年', '好客户数': 17964, '坏客户数': 8596 },
      { '分箱': '[30, 50万)', '下界(万)': 30, '上界(万)': 50, '数据集': '训练集', '好客户数': 20410, '坏客户数': 0 },
      { '分箱': '[30, 50万)', '下界(万)': 30, '上界(万)': 50, '数据集': '验证集', '好客户数': 3213, '坏客户数': 1072 },
      { '分箱': '[30, 50万)', '下界(万)': 30, '上界(万)': 50, '数据集': '2022年', '好客户数': 12938, '坏客户数': 0 },
      { '分箱': '[30, 50万)', '下界(万)': 30, '上界(万)': 50, '数据集': '2023年', '好客户数': 15035, '坏客户数': 2 },
      { '分箱': '[30, 50万)', '下界(万)': 30, '上界(万)': 50, '数据集': '2024年', '好客户数': 13664, '坏客户数': 0 },
      { '分箱': '[50万, ∞)', '下界(万)': 50, '上界(万)': 'inf', '数据集': '训练集', '好客户数': 5472, '坏客户数': 0 },
      { '分箱': '[50万, ∞)', '下界(万)': 50, '上界(万)': 'inf', '数据集': '验证集', '好客户数': 900, '坏客户数': 158 },
      { '分箱': '[50万, ∞)', '下界(万)': 50, '上界(万)': 'inf', '数据集': '2022年', '好客户数': 4438, '坏客户数': 0 },
      { '分箱': '[50万, ∞)', '下界(万)': 50, '上界(万)': 'inf', '数据集': '2023年', '好客户数': 8993, '坏客户数': 1 },
      { '分箱': '[50万, ∞)', '下界(万)': 50, '上界(万)': 'inf', '数据集': '2024年', '好客户数': 6809, '坏客户数': 0 },
    ],
    totalRecords: 25,
    type: 'table',
    code: `# 分箱分析柱状图
import pandas as pd
import matplotlib.pyplot as plt

# 输入：各数据集的分箱统计结果
# 绘制分箱中的好坏客户分布

fig, axes = plt.subplots(2, 3, figsize=(16, 10))

datasets = ['训练集', '验证集', '2022年', '2023年', '2024年']
good_cols = ['训练集-好', '验证集-好', '2022-好', '2023-好', '2024-好']
bad_cols = ['训练集-坏', '验证集-坏', '2022-坏', '2023-坏', '2024-坏']

for idx, (dataset, good_col, bad_col) in enumerate(zip(datasets, good_cols, bad_cols)):
    ax = axes[idx // 3, idx % 3]

    x = range(len(df))
    width = 0.35

    ax.bar([i - width/2 for i in x], df[good_col], width, label='好客户', color='green', alpha=0.7)
    ax.bar([i + width/2 for i in x], df[bad_col], width, label='坏客户', color='red', alpha=0.7)

    ax.set_xlabel('分箱')
    ax.set_ylabel('客户数')
    ax.set_title(f'{dataset}分箱分析')
    ax.set_xticks(x)
    ax.set_xticklabels(df['分箱'], rotation=45)
    ax.legend()
    ax.grid(axis='y', alpha=0.3)

# 隐藏最后一个空位
axes[1, 2].axis('off')

plt.tight_layout()
plt.show()`,
    conclusion: `# 分箱分析柱状图

## 重要发现：零值分箱的清晰展示

### 低额度区间（[0, 30万)）
- **好客户占比稳定**：75-79%
- **坏客户占比稳定**：21-25%
- **跨数据集一致性好** ✓

### 高额度区间（[30, 50万+)）
- **训练集**：零坏客户（⚠️）
- **验证集**：坏客户占25%以上（✓ 有样本）
- **2022年**：零坏客户（⚠️）
- **2023年**：极少坏客户（⚠️ 异常）
- **2024年**：零坏客户（⚠️ 回归）

## 零值分箱的危害
1. **WOE无法正常计算**
2. **导致IV异常高估**
3. **模型预测可靠性下降**

## 解决方案
1. **添加Laplace平滑**：每个分箱+1个好客户和1个坏客户
2. **重新定义分箱**：考虑按百分位划分而非固定值
3. **增加样本观察期**：等待高额度贷款的坏账暴露

## 业务启示
高额度贷款确实更安全，但不能完全忽视风险，需要长期监控`,
  },
};

const defaultData: {
  title: string;
  headers: string[];
  data: DataRow[];
  totalRecords: number;
  type?: 'table' | 'chart';
  code?: string;
  codeWithMetadata?: string;
  conclusion?: string;
  chartType?: string;
  result_format?: string;
} = {
  title: '请选择流程图中的节点查看分析内容',
  headers: ['提示'],
  data: [{ '提示': '点击左侧流程图中的任意节点，即可查看对应的分析结果' }],
  totalRecords: 0,
  code: undefined,
  codeWithMetadata: undefined,
  conclusion: undefined,
  result_format: undefined,
};

// 渲染图表的辅助函数
function renderChart(chartType: string | undefined, data: DataRow[]) {
  const chartHeight = 300;

  switch (chartType) {
    case 'scatter':
      // 散点图：支持多种格式
      // 检测数据格式：如果有'特征名称'和'数据集'列，则为Risk Model的多数据集散点图
      const hasFeatureAndDataset = data.length > 0 && '特征名称' in data[0] && '数据集' in data[0];

      if (hasFeatureAndDataset) {
        // Risk Model 散点图：多特征、多数据集的点
        // 获取所有特征和数据集，用于X轴分组
        const uniqueFeatures = Array.from(new Set(
          (data as Array<DataRow & Record<string, string | number>>)
            .map(row => String(row['特征名称'] ?? ''))
        ));

        const uniqueDatasets = Array.from(new Set(
          (data as Array<DataRow & Record<string, string | number>>)
            .map(row => String(row['数据集'] ?? ''))
        ));

        // 检测是否为差值图（只包含年份数据，没有训练集/验证集）
        const isDiffChart = !uniqueDatasets.includes('训练集') && !uniqueDatasets.includes('验证集');

        const datasetColors: Record<string, string> = {
          '训练集': '#ef4444',
          '验证集': '#f59e0b',
          '2022年': '#10b981',
          '2023年': '#3b82f6',
          '2024年': '#8b5cf6',
        };

        // 构建散点数据：特征索引作为X坐标分组
        const scatterData = (data as Array<DataRow & Record<string, string | number>>).map((row, idx) => {
          const featureName = String(row['特征名称'] ?? '');
          const dataset = String(row['数据集'] ?? '');

          // 找到第一个数值列（可能是'IV值'或'差值'）
          let yValue = 0;
          const numericKeys = Object.keys(row).filter(
            k => k !== '特征名称' && k !== '数据集' && !isNaN(Number(row[k]))
          );
          if (numericKeys.length > 0) {
            yValue = Number(row[numericKeys[0]]) || 0;
          }

          const featureIndex = uniqueFeatures.indexOf(featureName);
          const allDatasets = ['训练集', '验证集', '2022年', '2023年', '2024年'];
          const datasetIndex = allDatasets.indexOf(dataset);

          // 在特征组内添加数据集偏移
          const xOffset = datasetIndex >= 0 ? (datasetIndex - 2) * 0.08 : 0;

          return {
            x: featureIndex + xOffset,
            y: yValue,
            特征: featureName,
            数据集: dataset,
            fill: datasetColors[dataset] || '#6b7280',
          };
        });

        // 为Scatter组件生成图例标签
        const scatterLegends = uniqueDatasets.map(dataset => {
          const label = isDiffChart ? `${dataset} vs 训练集` : dataset;
          return { dataset, label, color: datasetColors[dataset] || '#6b7280' };
        });

        return (
          <ResponsiveContainer width="100%" height={chartHeight}>
            <ScatterChart
              data={scatterData}
              margin={{ top: 20, right: 20, bottom: 60, left: 60 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="x"
                type="number"
                domain={[-0.5, uniqueFeatures.length - 0.5]}
                ticks={uniqueFeatures.map((_, i) => i)}
                tickFormatter={(value) => uniqueFeatures[value] || ''}
                angle={-45}
                textAnchor="end"
                height={100}
                label={{ value: '特征名称', position: 'insideBottomRight', offset: -10 }}
              />
              <YAxis
                dataKey="y"
                type="number"
                label={{ value: '值', angle: -90, position: 'insideLeft' }}
              />
              <Tooltip
                cursor={{ strokeDasharray: '3 3' }}
                content={({ active, payload }) => {
                  if (active && payload && payload.length > 0) {
                    const d = payload[0].payload as {
                      特征: string;
                      数据集: string;
                      y: number;
                    };
                    const tooltipLabel = isDiffChart ? `${d.数据集} vs 训练集` : d.数据集;
                    return (
                      <div className="bg-white p-2 border border-gray-300 rounded shadow-lg">
                        <p className="text-sm font-bold">{d.特征}</p>
                        <p className="text-sm">{tooltipLabel}</p>
                        <p className="text-sm">值: {d.y.toFixed(3)}</p>
                      </div>
                    );
                  }
                  return null;
                }}
              />
              <Legend
                verticalAlign="top"
                height={36}
                wrapperStyle={{ paddingBottom: '10px' }}
              />
              {scatterLegends.map(({ dataset, label, color }) => (
                <Scatter
                  key={dataset}
                  name={label}
                  data={scatterData.filter(p => p.数据集 === dataset)}
                  fill={color}
                />
              ))}
            </ScatterChart>
          </ResponsiveContainer>
        );
      } else {
        // 原有的 data-analysis 散点图逻辑
        const ageGroups = ['25-30岁', '31-40岁', '41-50岁'];
        const incomeColors: Record<string, string> = {
          '低收入(8-12k)': '#ef4444',
          '中等收入(12-20k)': '#f59e0b',
          '高收入(20k+)': '#10b981',
        };

        const scatterPoints: Array<{
          x: number;
          y: number;
          收入等级: string;
          age: string;
          fill: string;
        }> = [];

        (data as Array<DataRow & Record<string, number>>).forEach((row) => {
          const age = String(row['年龄段'] ?? '');
          const xValue = ageGroups.indexOf(age);

          Object.entries(incomeColors).forEach(([incomeKey, color]) => {
            const yValue = Number(row[incomeKey]) || 0;
            scatterPoints.push({
              x: xValue,
              y: yValue,
              收入等级: incomeKey,
              age: age,
              fill: color,
            });
          });
        });

        return (
          <ResponsiveContainer width="100%" height={chartHeight}>
            <ScatterChart
              data={scatterPoints}
              margin={{ top: 20, right: 20, bottom: 60, left: 60 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="x"
                type="number"
                domain={[-0.5, 2.5]}
                ticks={[0, 1, 2]}
                tickFormatter={(value) => ageGroups[value] || ''}
                label={{ value: '年龄段', position: 'insideBottomRight', offset: -10 }}
              />
              <YAxis
                dataKey="y"
                type="number"
                label={{ value: '违约率(%)', angle: -90, position: 'insideLeft' }}
              />
              <Tooltip
                cursor={{ strokeDasharray: '3 3' }}
                content={({ active, payload }) => {
                  if (active && payload && payload.length > 0) {
                    const d = payload[0].payload as {
                      收入等级: string;
                      age: string;
                      y: number;
                    };
                    return (
                      <div className="bg-white p-2 border border-gray-300 rounded shadow-lg">
                        <p className="text-sm">{d.age}</p>
                        <p className="text-sm">{d.收入等级}</p>
                        <p className="text-sm font-bold">违约率: {d.y}%</p>
                      </div>
                    );
                  }
                  return null;
                }}
              />
              <Legend
                verticalAlign="top"
                height={36}
                wrapperStyle={{ paddingBottom: '10px' }}
              />
              <Scatter name="低收入(8-12k)" data={scatterPoints.filter(p => p.fill === '#ef4444')} fill="#ef4444" />
              <Scatter name="中等收入(12-20k)" data={scatterPoints.filter(p => p.fill === '#f59e0b')} fill="#f59e0b" />
              <Scatter name="高收入(20k+)" data={scatterPoints.filter(p => p.fill === '#10b981')} fill="#10b981" />
            </ScatterChart>
          </ResponsiveContainer>
        );
      }

    case 'line':
      // 折线图：逾期率趋势
      return (
        <ResponsiveContainer width="100%" height={chartHeight}>
          <LineChart data={data} margin={{ top: 20, right: 20, bottom: 20, left: 20 }}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="时间" />
            <YAxis label={{ value: '逾期率(%)', angle: -90, position: 'insideLeft' }} />
            <Tooltip />
            <Legend />
            <Line
              type="monotone"
              dataKey="逾期率(%)"
              stroke="#ef4444"
              dot={{ fill: '#dc2626', r: 5 }}
              strokeWidth={2}
              activeDot={{ r: 7 }}
              name="逾期率(%)"
            />
          </LineChart>
        </ResponsiveContainer>
      );

    case 'bar':
      // 柱状图：特征重要性
      return (
        <ResponsiveContainer width="100%" height={chartHeight}>
          <BarChart data={data} margin={{ top: 20, right: 20, bottom: 20, left: 20 }}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="特征" />
            <YAxis label={{ value: '重要性分数', angle: -90, position: 'insideLeft' }} />
            <Tooltip />
            <Legend />
            <Bar
              dataKey="重要性分数"
              fill="#8b5cf6"
              radius={[8, 8, 0, 0]}
              name="重要性分数"
            />
          </BarChart>
        </ResponsiveContainer>
      );

    default:
      return null;
  }
}

export function DataTable({ selectedNodeId, onNodeDeselect, currentDatasetId = 'ecommerce_analytics', onProjectUpdate, onNodeDelete }: DataTableProps) {
  const [apiData, setApiData] = useState<PaginatedData<any> | null>(null);
  const [dictResult, setDictResult] = useState<any | null>(null);
  const [apiCode, setApiCode] = useState<string>('');
  const [apiCodeWithMetadata, setApiCodeWithMetadata] = useState<string>('');
  const [apiMarkdown, setApiMarkdown] = useState<string>('');
  const [isLoadingApi, setIsLoadingApi] = useState(false);
  const [nodeResultFormat, setNodeResultFormat] = useState<string>('parquet');
  const [isEditingMarkdown, setIsEditingMarkdown] = useState(false);
  const [nodeExecutionStatus, setNodeExecutionStatus] = useState<string | null>(null);
  const [editingMarkdown, setEditingMarkdown] = useState<string>('');
  const [isSavingMarkdown, setIsSavingMarkdown] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [displayedNodeId, setDisplayedNodeId] = useState<string | null>(selectedNodeId);
  const [isEditingCode, setIsEditingCode] = useState(false);
  const [editingCode, setEditingCode] = useState<string>('');
  const [isSavingCode, setIsSavingCode] = useState(false);
  // Per-node panel state tracking
  const [nodeConclusionStates, setNodeConclusionStates] = useState<Record<string, boolean>>({});
  const [nodeViewModeStates, setNodeViewModeStates] = useState<Record<string, 'table' | 'code'>>({});
  // Execution state tracking
  const [isExecuting, setIsExecuting] = useState(false);
  const [nodeErrors, setNodeErrors] = useState<Record<string, string>>({});
  // Force refresh of node data after execution (triggered by incrementing counter)
  const [nodeRefreshKey, setNodeRefreshKey] = useState(0);

  const { projectCache, loadProject, updateProjectCache } = useProjectCache();
  const markdownChanges = useUnsavedChanges();
  const codeChanges = useUnsavedChanges();

  const { toast } = useToast();

  // Get per-node conclusion state, or use default if not set
  const getNodeConclusionState = (nodeId: string | null): boolean => {
    if (!nodeId) return false;
    return nodeConclusionStates[nodeId] ?? false;
  };

  // Set per-node conclusion state
  const setNodeConclusionState = (nodeId: string | null, state: boolean) => {
    if (!nodeId) return;
    setNodeConclusionStates(prev => ({
      ...prev,
      [nodeId]: state
    }));
  };

  // Get per-node viewMode state, default to 'table'
  const getNodeViewMode = (nodeId: string | null): 'table' | 'code' => {
    if (!nodeId) return 'table';
    return nodeViewModeStates[nodeId] ?? 'table';
  };

  // Set per-node viewMode state
  const setNodeViewMode = (nodeId: string | null, mode: 'table' | 'code') => {
    if (!nodeId) return;
    setNodeViewModeStates(prev => ({
      ...prev,
      [nodeId]: mode
    }));
  };

  // Use currentDatasetId directly - no mapping needed as we now load projects dynamically
  const projectId = currentDatasetId;

  // Check for unsaved changes when selectedNodeId (from props) changes
  useEffect(() => {
    // If the props selectedNodeId is different from what we're currently displaying
    if (selectedNodeId !== displayedNodeId) {
      // Check if there are unsaved changes in either markdown or code
      const hasUnsavedMarkdown = markdownChanges.hasChanges && isEditingMarkdown;
      const hasUnsavedCode = codeChanges.hasChanges && isEditingCode;

      if (hasUnsavedMarkdown) {
        // Show dialog for unsaved markdown
        markdownChanges.checkAndNavigate(() => {
          setDisplayedNodeId(selectedNodeId);
        });
      } else if (hasUnsavedCode) {
        // Show dialog for unsaved code
        codeChanges.checkAndNavigate(() => {
          setDisplayedNodeId(selectedNodeId);
        });
      } else {
        // No unsaved changes, just update the displayed node immediately
        setDisplayedNodeId(selectedNodeId);
      }
    }
  }, [selectedNodeId, displayedNodeId, markdownChanges.hasChanges, isEditingMarkdown, codeChanges.hasChanges, isEditingCode]);

  // 从API加载节点数据（基于当前显示的节点）
  useEffect(() => {
    if (!displayedNodeId) {
      setApiData(null);
      setApiCode('');
      setApiMarkdown('');
      setCurrentPage(1);
      markdownChanges.reset();
      return;
    }

    // If markdown is being edited, show confirmation dialog before switching nodes
    const loadNewNode = async () => {
      try {
        setIsLoadingApi(true);

        // Load project cache to get node metadata
        await loadProject(currentDatasetId);

        // Find node in cached project data to get result_format and execution_status
        const cachedProject = projectCache[projectId];
        let isNodeNotExecuted = false;
        let nodeResultFormat: string = 'parquet';
        if (cachedProject) {
          const node = cachedProject.nodes.find(n => n.id === displayedNodeId);
          if (node) {
            nodeResultFormat = node.result_format || 'parquet';
            setNodeResultFormat(nodeResultFormat);
            setNodeExecutionStatus(node.execution_status || null);

            // If node is not executed, force code view and enter edit mode
            if (node.execution_status === 'not_executed') {
              isNodeNotExecuted = true;
              setNodeViewMode(displayedNodeId, 'code');
              setIsEditingCode(true);
            } else if (node.execution_status === 'pending_validation') {
              // 问题修复3: 当节点执行失败时（pending_validation），自动进入编辑模式以便修复
              setNodeViewMode(displayedNodeId, 'code');
              setIsEditingCode(true);
            } else if (node.result_format === 'image' || node.result_format === 'visualization') {
              // For image nodes, automatically show the visualization
              setNodeResultFormat(node.result_format);
              setNodeConclusionState(displayedNodeId, true);
              setNodeViewMode(displayedNodeId, 'table');
            } else if (node.result_format === 'pkl') {
              // For tool nodes with pkl format, default to code view
              const defaultPanel = getDefaultPanel(node.result_format);
              setNodeViewMode(displayedNodeId, defaultPanel === 'code' ? 'code' : 'table');
            }
          } else {
            setNodeResultFormat('parquet'); // default
            setNodeExecutionStatus(null);
          }
        }

        // 检查是否是dict结果
        const projectData = await getProject(projectId);
        const currentNode = projectData.nodes.find((n: any) => n.id === displayedNodeId);


        if (currentNode?.result_is_dict) {
          // 加载dict结果
          try {
            const dictData = await getDictResult(projectId, displayedNodeId);
            setDictResult(dictData);
            setApiData(null);
            // Ensure view mode is set to 'table' for dict results
            setNodeViewMode(displayedNodeId, 'table');
          } catch (err) {
            console.error('[DataTable] Failed to load dict result:', err);
            setDictResult(null);
          }
        } else {
          // 根据结果格式决定是否加载数据
          // 某些格式（如pkl）不需要通过API加载数据
          setDictResult(null);
          if (shouldLoadResultData(nodeResultFormat)) {
            try {
              const data = await getNodeData(projectId, displayedNodeId, 1, 10);
              if (data.format === 'parquet' || data.format === 'image' || data.format === 'visualization' || data.format === 'pkl') {
                setApiData(data);
              }
            } catch (err) {
              // 未执行节点没有数据，这是正常的
              console.log('No data available for node (may not be executed)', displayedNodeId);
              setApiData(null);
            }
          } else {
            // 某些格式（如pkl）不需要加载结果数据
            setApiData(null);
          }
        }

        // 加载代码
        try {
          const codeData = await getNodeCode(projectId, displayedNodeId);
          // Keep full code with metadata for reference
          setApiCodeWithMetadata(codeData.code);
          // Strip metadata comments and clean empty lines for editing
          const cleanedCode = stripMetadataComments(codeData.code);
          setApiCode(cleanedCode);
          // Initialize editingCode with cleaned code
          setEditingCode(cleanedCode);
        } catch (err) {
          console.log('No code available for node', displayedNodeId);
          setApiCode('');
          setApiCodeWithMetadata('');
          setEditingCode('');
        }

        // 加载markdown总结
        try {
          const markdownData = await getNodeMarkdown(projectId, displayedNodeId);
          setApiMarkdown(markdownData.markdown);
        } catch (err) {
          console.log('No markdown available for node', displayedNodeId);
          setApiMarkdown('');
        }

        // Reset editing state and unsaved changes for new node
        // But only reset markdown editing - code editing is kept for unexecuted nodes
        setIsEditingMarkdown(false);
        // For executed nodes, reset code editing state; for unexecuted nodes, keep it
        if (!isNodeNotExecuted) {
          setIsEditingCode(false);
        }
        markdownChanges.reset();
        codeChanges.reset();
      } catch (err) {
        console.error('Failed to load node data:', err);
      } finally {
        setIsLoadingApi(false);
      }
    };

    setCurrentPage(1); // 重置分页
    loadNewNode();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [displayedNodeId, projectId, currentDatasetId, nodeRefreshKey]);


  // 当currentPage改变时，重新加载该页的数据
  useEffect(() => {
    if (!displayedNodeId) {
      return;
    }

    // 只有当页码不是1时才需要加载（因为初始化时已经加载过第一页）
    if (currentPage === 1) {
      return;
    }

    const loadPageData = async () => {
      try {
        setIsLoadingApi(true);
        const data = await getNodeData(projectId, displayedNodeId, currentPage, 10);
        if (data.format === 'parquet' || data.format === 'image' || data.format === 'visualization') {
          setApiData(data);
        }
      } catch (err) {
        console.error('Failed to load page data:', err);
      } finally {
        setIsLoadingApi(false);
      }
    };

    loadPageData();
  }, [currentPage, displayedNodeId, projectId]);

  // 从缓存中同步获取节点信息（不需要异步等待）
  const cachedNode = displayedNodeId
    ? projectCache[projectId]?.nodes.find(n => n.id === displayedNodeId)
    : null;

  const cachedExecutionStatus = cachedNode?.execution_status || null;
  const cachedResultFormat = cachedNode?.result_format || null;

  // 优先使用缓存中的执行状态，如果没有则使用状态中的值
  const effectiveNodeExecutionStatus = cachedExecutionStatus !== null ? cachedExecutionStatus : nodeExecutionStatus;

  // 优先使用缓存中的结果格式，如果没有则使用状态中的值
  const effectiveNodeResultFormat = cachedResultFormat !== null ? cachedResultFormat : nodeResultFormat;

  // Get user's preference for showing markdown panel
  const nodeShowsConclusion = getNodeConclusionState(displayedNodeId);
  // Respect user's preference - don't force markdown panel for any node type
  const effectiveShowConclusion = nodeShowsConclusion;

  // Get current node's viewMode
  const currentNodeViewMode = getNodeViewMode(displayedNodeId);

  // 优先使用API数据，如果没有则回退到硬编码数据
  // 如果displayedNodeId存在，则使用API加载的数据（即使是空值也要用，不要回退到defaultData）
  // 使用effectiveNodeResultFormat而不是nodeResultFormat以确保首次加载时图片正确显示
  const currentData = displayedNodeId
    ? {
        title: displayedNodeId || 'Data',
        headers: apiData?.columns || [],
        data: apiData ? (Array.isArray(apiData.data) ? apiData.data : [apiData.data]) as DataRow[] : [],
        totalRecords: apiData?.total_records || 0,
        result_format: effectiveNodeResultFormat,
        type: (effectiveNodeResultFormat === 'image' || effectiveNodeResultFormat === 'visualization') ? 'chart' : 'table' as const,
        code: apiCode,
        codeWithMetadata: apiCodeWithMetadata,
        conclusion: apiMarkdown,
        chartType: undefined,
      }
    : defaultData;

  const hasConclusion = !!currentData.conclusion;

  // Handle markdown edit mode
  const handleMarkdownEdit = () => {
    setEditingMarkdown(apiMarkdown);
    setIsEditingMarkdown(true);
    markdownChanges.reset(); // Clear any previous changes
  };

  const handleMarkdownChange = (newContent: string) => {
    setEditingMarkdown(newContent);
    // Mark as changed if different from original, as saved if same
    if (newContent !== apiMarkdown) {
      markdownChanges.markAsChanged();
    } else {
      markdownChanges.markAsSaved();
    }
  };

  const handleMarkdownSave = async () => {
    if (!displayedNodeId || !markdownChanges.hasChanges) return;

    setIsSavingMarkdown(true);
    try {
      await updateNodeMarkdown(projectId, displayedNodeId, editingMarkdown);
      setApiMarkdown(editingMarkdown);
      setIsEditingMarkdown(false);
      markdownChanges.markAsSaved();
    } catch (err) {
      console.error('Failed to save markdown:', err);
      // TODO: Show error toast
      throw err;
    } finally {
      setIsSavingMarkdown(false);
    }
  };

  const handleMarkdownCancel = () => {
    if (markdownChanges.hasChanges) {
      // Show dialog for unsaved changes when canceling
      markdownChanges.checkAndNavigate(() => {
        setIsEditingMarkdown(false);
      });
    } else {
      // No changes, just exit edit mode
      setIsEditingMarkdown(false);
    }
  };

  // Handle code edit mode
  const handleCodeEdit = () => {
    setEditingCode(apiCode);
    setIsEditingCode(true);
    codeChanges.markAsSaved(); // Start fresh in edit mode
  };

  const handleCodeChange = (newContent: string) => {
    setEditingCode(newContent);
    // Mark as changed if different from original
    if (newContent !== apiCode) {
      codeChanges.markAsChanged();
    } else {
      codeChanges.markAsSaved();
    }
  };

  const handleCodeSave = async () => {
    if (!displayedNodeId) return;

    setIsSavingCode(true);
    try {
      // Get the actual code from the editor textarea in the DOM
      const editorContainer = document.querySelector('.editor-container');
      let codeToSave = editingCode;

      if (editorContainer) {
        const textarea = editorContainer.querySelector('textarea') as HTMLTextAreaElement | null;
        if (textarea && textarea.value) {
          codeToSave = textarea.value;
        }
      }

      if (!codeToSave || codeToSave.trim() === '') {
        console.warn('[handleCodeSave] No code to save');
        setIsSavingCode(false);
        return;
      }

      // Save without metadata comments and with cleaned empty lines
      const cleanedCodeToSave = stripMetadataComments(codeToSave);
      const result = await updateNodeCode(projectId, displayedNodeId, cleanedCodeToSave);

      // Backend returns code with updated metadata comments
      const fullCode = result.code || cleanedCodeToSave;
      const cleanedCode = stripMetadataComments(fullCode);

      // Display: show full code with metadata
      setApiCodeWithMetadata(fullCode);
      // Edit: show cleaned code without metadata
      setApiCode(cleanedCode);
      setEditingCode(cleanedCode);
      setIsEditingCode(false);
      codeChanges.markAsSaved();

      // Trigger project update to refresh flow diagram with new dependencies
      onProjectUpdate?.();
    } catch (err) {
      console.error('Failed to save code:', err);
      throw err;
    } finally {
      setIsSavingCode(false);
    }
  };

  const handleCodeCancel = () => {
    if (codeChanges.hasChanges) {
      // Show dialog for unsaved changes when canceling
      codeChanges.checkAndNavigate(() => {
        setIsEditingCode(false);
      });
    } else {
      // No changes, just exit edit mode
      setIsEditingCode(false);
    }
  };

  const handleExecuteNode = async () => {
    if (!displayedNodeId) return;

    // First, save code changes if any
    if (codeChanges.hasChanges && isEditingCode) {
      try {
        await updateNodeCode(projectId, displayedNodeId, editingCode);
        codeChanges.markAsSaved();
      } catch (error) {
        toast({
          variant: 'destructive',
          description: 'Failed to save code before execution',
        });
        return;
      }
    }

    setIsExecuting(true);
    // Clear previous error
    setNodeErrors((prev) => ({ ...prev, [displayedNodeId]: '' }));

    try {
      const result = await executeNode(projectId, displayedNodeId);

      if (result.status === 'success') {
        toast({
          description: `Node executed successfully in ${result.execution_time?.toFixed(2)}s`,
        });

        // Force reload from backend (bypass cache) to get updated execution status and depends_on
        // This enables the dynamic dependency discovery system:
        // - Backend analyzed the code and updated node['depends_on']
        // - Frontend reloads project.json to get the updated dependencies
        // - FlowDiagram re-renders and displays new edges based on depends_on
        try {
          const updatedProject = await getProject(projectId);
          // Update cache with new project data
          if (projectCache && updatedProject) {
            updateProjectCache(projectId, updatedProject);
          }
        } catch (error) {
          console.error('Failed to refresh project data:', error);
        }

        // Update local node execution status immediately for UI refresh
        setNodeExecutionStatus('validated');

        // Trigger flow diagram refresh to show updated execution status and new edges
        onProjectUpdate?.();

        // Force reload DataTable region (dict result detection, node view mode, and result data)
        // This is critical because:
        // - The node may now have a dict result (is_dict_result flag was set during execution)
        // - The result format may have changed (null -> 'parquet')
        // - The execution status changed (pending -> validated)
        // Incrementing nodeRefreshKey triggers the useEffect at line 3602 which reloads everything
        setNodeRefreshKey(prev => prev + 1);
      } else if (result.status === 'pending_validation') {
        // Show error message
        setNodeErrors((prev) => ({
          ...prev,
          [displayedNodeId]: result.error_message || 'Execution failed',
        }));
        toast({
          variant: 'destructive',
          description: result.error_message || 'Execution failed - check error details',
        });
        // Update local node execution status to reflect pending validation
        setNodeExecutionStatus('pending_validation');

        // IMPORTANT: Do NOT refresh DataTable on execution failure!
        // Reason:
        // - Code changes were already saved to backend before execution
        // - User needs to see and edit their code to fix the error
        // - Reloading code would revert to the "saved" version, losing the editing context
        // - User must fix the code and retry execution
        //
        // ONLY refresh flow diagram to show the updated error status
        // Force reload from backend to update node status to pending_validation
        try {
          const updatedProject = await getProject(projectId);
          if (projectCache && updatedProject) {
            updateProjectCache(projectId, updatedProject);
          }
        } catch (error) {
          console.error('Failed to refresh project data:', error);
        }
        // Refresh flow diagram to show updated error status
        onProjectUpdate?.();

        // ❌ REMOVED: setNodeRefreshKey(prev => prev + 1);
        // This would trigger the useEffect to reload code from backend,
        // which would erase the user's edited code and revert to the saved version.
      } else {
        toast({
          variant: 'destructive',
          description: result.error_message || 'Execution error',
        });
        // Only refresh flow diagram to show updated status
        // Do NOT refresh DataTable - user's code should be preserved for fixing
        onProjectUpdate?.();
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Execution failed';
      setNodeErrors((prev) => ({
        ...prev,
        [displayedNodeId]: message,
      }));
      toast({
        variant: 'destructive',
        description: message,
      });
      // Only refresh flow diagram on error
      // Do NOT refresh DataTable - user's code should be preserved for fixing
      onProjectUpdate?.();
    } finally {
      setIsExecuting(false);
    }
  };

  // Handle pagination
  const totalPages = apiData?.total_pages || 1;
  const pageSize = 5; // Show 5 page buttons at a time

  const getPageNumbers = () => {
    const pages: (number | string)[] = [];

    // Always show first page
    if (currentPage > pageSize) {
      pages.push(1);
      if (currentPage > pageSize + 1) {
        pages.push('...');
      }
    }

    // Show pages around current page
    for (let i = Math.max(1, currentPage - 2); i <= Math.min(totalPages, currentPage + 2); i++) {
      pages.push(i);
    }

    // Always show last page if not already shown
    if (currentPage < totalPages - pageSize + 1) {
      if (currentPage < totalPages - pageSize) {
        pages.push('...');
      }
      pages.push(totalPages);
    }

    return pages;
  };

  const handlePageChange = (page: number) => {
    if (page >= 1 && page <= totalPages) {
      setCurrentPage(page);
    }
  };

  // Helper function to check for unsaved changes when closing data panel or switching nodes
  // Checks both markdown and code changes
  const checkAndExecuteAction = (action: () => void) => {
    const hasUnsavedMarkdown = markdownChanges.hasChanges && isEditingMarkdown;
    const hasUnsavedCode = codeChanges.hasChanges && isEditingCode;

    if (hasUnsavedMarkdown) {
      // When markdown has changes, show markdown dialog
      // After user handles markdown (save/discard), this callback will be triggered
      markdownChanges.checkAndNavigate(() => {
        // Check code changes again after markdown is handled
        const hasUnsavedCodeNow = codeChanges.hasChanges && isEditingCode;
        if (hasUnsavedCodeNow) {
          // Show code dialog next
          codeChanges.checkAndNavigate(action);
        } else {
          // No more changes, execute the action
          action();
        }
      });
    } else if (hasUnsavedCode) {
      // Show code dialog directly
      codeChanges.checkAndNavigate(action);
    } else {
      // No changes, execute action immediately
      action();
    }
  };

  // Helper function to check for unsaved changes when closing markdown panel
  // Only checks markdown changes, allows closing markdown panel while editing code
  const checkAndCloseMarkdownPanel = () => {
    if (markdownChanges.hasChanges && isEditingMarkdown) {
      markdownChanges.checkAndNavigate(() => {
        setNodeConclusionState(displayedNodeId, false);
      });
    } else {
      setNodeConclusionState(displayedNodeId, false);
    }
  };

  return (
    <div className="bg-card rounded-lg border border-border overflow-visible flex flex-col h-full relative">
      {displayedNodeId && (
        <Button
          variant="ghost"
          size="icon"
          className="absolute -top-1.5 -right-1.5 h-6 w-6 rounded-full hover:bg-muted z-10 bg-card border border-border flex items-center justify-center"
          onClick={() => {
            checkAndExecuteAction(() => {
              onNodeDeselect?.();
            });
          }}
          title="关闭数据面板"
        >
          <X className="h-3.5 w-3.5" />
        </Button>
      )}
      <div className="flex items-center justify-between px-4 py-3 border-b border-border">
        <h3 className="text-sm font-semibold text-foreground">
          {currentData.title}
        </h3>
        <div className="flex gap-2 items-center">
          {/* Code toggle button - hidden for formats like pkl that don't have result tables */}
          {shouldShowCodePanel(effectiveNodeResultFormat) && (
            <Button
              variant={effectiveNodeExecutionStatus === 'not_executed' || effectiveNodeExecutionStatus === 'pending_validation' ? 'default' : (currentNodeViewMode === 'code' ? 'default' : 'ghost')}
              size="icon"
              className={`h-8 w-8 ${effectiveNodeExecutionStatus === 'not_executed' || effectiveNodeExecutionStatus === 'pending_validation' ? 'opacity-50 cursor-not-allowed' : ''}`}
              onClick={() => {
                if (effectiveNodeExecutionStatus === 'not_executed' || effectiveNodeExecutionStatus === 'pending_validation') {
                  toast({
                    description: 'Please execute the code first',
                  });
                } else {
                  setNodeViewMode(displayedNodeId, currentNodeViewMode === 'code' ? 'table' : 'code');
                }
              }}
              disabled={effectiveNodeExecutionStatus !== 'not_executed' && effectiveNodeExecutionStatus !== 'pending_validation' && !currentData.code}
              title={effectiveNodeExecutionStatus === 'not_executed' || effectiveNodeExecutionStatus === 'pending_validation' ? 'Run the code first to view results' : ''}
            >
              <Code className="h-4 w-4" />
            </Button>
          )}

          {/* Markdown toggle button - always shown for executed nodes */}
          <Button
            variant={nodeShowsConclusion ? 'default' : 'ghost'}
            size="icon"
            className={`h-8 w-8 ${effectiveNodeExecutionStatus === 'not_executed' || effectiveNodeExecutionStatus === 'pending_validation' ? 'opacity-50 cursor-not-allowed' : ''}`}
            onClick={() => {
              if (effectiveNodeExecutionStatus === 'not_executed' || effectiveNodeExecutionStatus === 'pending_validation') {
                toast({
                  description: 'Please execute the code first',
                });
              } else if (nodeShowsConclusion) {
                checkAndCloseMarkdownPanel();
              } else {
                setNodeConclusionState(displayedNodeId, true);
              }
            }}
            disabled={!hasConclusion && (effectiveNodeExecutionStatus === 'not_executed' || effectiveNodeExecutionStatus === 'pending_validation')}
          >
            <FileText className="h-4 w-4" />
          </Button>

          {/* Delete button - appears after md toggle */}
          <Button
            variant="ghost"
            size="icon"
            className="h-8 w-8 text-red-500 hover:bg-red-50 hover:text-red-600"
            onClick={() => {
              if (!displayedNodeId) return;

              const needsConfirmation = effectiveNodeExecutionStatus !== 'not_executed';
              if (needsConfirmation) {
                const confirmed = window.confirm(`确定删除节点 ${displayedNodeId} 吗？此操作不可撤销。`);
                if (!confirmed) return;
              }

              // Call the delete callback and deselect
              onNodeDelete?.(displayedNodeId);
              onNodeDeselect?.();
            }}
            title="删除此节点"
          >
            <Trash2 className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {effectiveNodeExecutionStatus === 'not_executed' || effectiveNodeExecutionStatus === 'pending_validation' ? (
        <div className="h-full flex flex-col">
          <div className="flex items-center gap-2 px-4 py-2 border-b border-border">
            <Button
              size="sm"
              onClick={handleCodeSave}
              disabled={!codeChanges.hasChanges || isSavingCode}
              className="h-7 px-2 text-xs"
            >
              Save
            </Button>
            <Button
              size="sm"
              onClick={handleCodeCancel}
              variant="outline"
              disabled={isSavingCode}
              className="h-7 px-2 text-xs"
            >
              Cancel
            </Button>
            <div className="flex-1" />
            <Button
              size="sm"
              onClick={handleExecuteNode}
              disabled={isExecuting}
              className="h-7 px-3 text-xs bg-green-600 hover:bg-green-700"
            >
              {isExecuting ? (
                <>
                  <Loader2 className="h-3 w-3 mr-1 animate-spin" />
                  Executing...
                </>
              ) : (
                <>
                  <Play className="h-3 w-3 mr-1" />
                  Execute
                </>
              )}
            </Button>
          </div>
          {/* Show error message if execution failed */}
          {nodeErrors[displayedNodeId || ''] && (
            <div className="px-4 py-2 bg-red-50 border-b border-red-200">
              <div className="flex items-start gap-2">
                <AlertCircle className="h-4 w-4 text-red-600 flex-shrink-0 mt-0.5" />
                <div className="text-xs text-red-600">
                  <p className="font-semibold">Execution Error</p>
                  <p className="mt-1">{nodeErrors[displayedNodeId || '']}</p>
                </div>
              </div>
            </div>
          )}
          <CodeEditor
            value={editingCode}
            onChange={handleCodeChange}
          />
        </div>
      ) : dictResult && !effectiveShowConclusion ? (
        // Display dict result without markdown panel if markdown is not explicitly opened
        // Support view mode toggle between dict result (table) and code editor
        currentNodeViewMode === 'code' ? (
          <div className="h-full flex flex-col">
            <div className="flex items-center gap-2 px-4 py-2 border-b border-border">
              <Button
                size="sm"
                onClick={handleCodeSave}
                disabled={!codeChanges.hasChanges || isSavingCode}
                className="h-7 px-2 text-xs"
              >
                Save
              </Button>
              <Button
                size="sm"
                onClick={handleCodeCancel}
                variant="outline"
                disabled={isSavingCode}
                className="h-7 px-2 text-xs"
              >
                Cancel
              </Button>
              <div className="flex-1" />
              <Button
                size="sm"
                onClick={handleExecuteNode}
                disabled={isExecuting}
                className="h-7 px-3 text-xs bg-green-600 hover:bg-green-700"
              >
                {isExecuting ? (
                  <>
                    <Loader2 className="h-3 w-3 mr-1 animate-spin" />
                    Executing...
                  </>
                ) : (
                  <>
                    <Play className="h-3 w-3 mr-1" />
                    Execute
                  </>
                )}
              </Button>
            </div>
            {nodeErrors[displayedNodeId || ''] && (
              <div className="px-4 py-2 bg-red-50 border-b border-red-200">
                <div className="flex items-start gap-2">
                  <AlertCircle className="h-4 w-4 text-red-600 flex-shrink-0 mt-0.5" />
                  <div className="text-xs text-red-600">
                    <p className="font-semibold">Execution Error</p>
                    <p className="mt-1">{nodeErrors[displayedNodeId || '']}</p>
                  </div>
                </div>
              </div>
            )}
            <CodeEditor
              value={editingCode}
              onChange={handleCodeChange}
            />
          </div>
        ) : (
          <div className="h-full overflow-auto">
            <DictResultDisplay
              keys={dictResult.keys}
              tables={dictResult.tables}
            />
          </div>
        )
      ) : effectiveShowConclusion ? (
        <ResizablePanelGroup direction="horizontal" className="flex-1">
          <ResizablePanel defaultSize={60} minSize={30}>
            {/* 问题修复2: 在数据面板中显示错误消息 */}
            {nodeErrors[displayedNodeId || ''] && (
              <div className="px-4 py-2 bg-red-50 border-b border-red-200">
                <div className="flex items-start gap-2">
                  <AlertCircle className="h-4 w-4 text-red-600 flex-shrink-0 mt-0.5" />
                  <div className="text-xs text-red-600">
                    <p className="font-semibold">Execution Error</p>
                    <p className="mt-1">{nodeErrors[displayedNodeId || '']}</p>
                  </div>
                </div>
              </div>
            )}
            {currentData.type === 'chart' && currentNodeViewMode === 'table' ? (
              <div className="w-full h-full flex items-center justify-center p-4 bg-muted/10">
                {currentData.result_format === 'image' || currentData.result_format === 'visualization' ? (
                  <img
                    src={getFileUrl(projectId, displayedNodeId || '', currentData.result_format)}
                    alt={`${displayedNodeId} visualization`}
                    style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }}
                    onError={(e) => {
                      console.error(`Failed to load image for node ${displayedNodeId}:`, e);
                      (e.target as HTMLImageElement).src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="200" height="200"%3E%3Crect width="200" height="200" fill="%23f0f0f0"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-size="14" fill="%23999"%3EImage not found%3C/text%3E%3C/svg%3E';
                    }}
                  />
                ) : (
                  renderChart(currentData.chartType, currentData.data)
                )}
              </div>
            ) : currentNodeViewMode === 'table' ? (
              dictResult ? (
                <DictResultDisplay
                  keys={dictResult.keys}
                  tables={dictResult.tables}
                />
              ) : (
                <div className="overflow-x-auto h-full">
                  <Table>
                    <TableHeader>
                      <TableRow className="bg-table-header hover:bg-table-header">
                        {currentData.headers.map((header, index) => (
                          <TableHead key={index} className="font-semibold whitespace-nowrap">
                            {header}
                          </TableHead>
                        ))}
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {currentData.data.map((row, rowIndex) => (
                        <TableRow
                          key={rowIndex}
                          className="hover:bg-table-hover transition-colors"
                        >
                          {currentData.headers.map((header, colIndex) => (
                            <TableCell
                              key={colIndex}
                              className={colIndex === 0 ? "font-medium whitespace-nowrap" : "whitespace-nowrap"}
                            >
                              {row[header]}
                            </TableCell>
                          ))}
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              )
            ) : isEditingCode ? (
              <div className="h-full flex flex-col">
                <div className="flex items-center gap-2 px-4 py-2 border-b border-border">
                  <Button
                    size="sm"
                    onClick={handleCodeSave}
                    disabled={!codeChanges.hasChanges || isSavingCode}
                    className="h-7 px-2 text-xs"
                  >
                    Save
                  </Button>
                  <Button
                    size="sm"
                    onClick={handleCodeCancel}
                    variant="outline"
                    disabled={isSavingCode}
                    className="h-7 px-2 text-xs"
                  >
                    Cancel
                  </Button>
                  <div className="flex-1" />
                  <Button
                    size="sm"
                    onClick={handleExecuteNode}
                    disabled={isExecuting}
                    className="h-7 px-3 text-xs bg-green-600 hover:bg-green-700"
                  >
                    {isExecuting ? (
                      <>
                        <Loader2 className="h-3 w-3 mr-1 animate-spin" />
                        Executing...
                      </>
                    ) : (
                      <>
                        <Play className="h-3 w-3 mr-1" />
                        Execute
                      </>
                    )}
                  </Button>
                </div>
                <CodeEditor
                  value={editingCode}
                  onChange={handleCodeChange}
                />
              </div>
            ) : (
              <ScrollArea className="h-full">
                <div
                  className="p-4 cursor-text hover:bg-muted/10 transition-colors"
                  onDoubleClick={handleCodeEdit}
                  title="Double-click to edit"
                >
                  {/* @ts-ignore */}
                  <SyntaxHighlighter
                    language="python"
                    style={atomOneDark}
                    className="text-sm"
                    customStyle={{
                      margin: 0,
                      padding: 0,
                      backgroundColor: 'transparent',
                    }}
                  >
                    {currentData.codeWithMetadata || currentData.code}
                  </SyntaxHighlighter>
                </div>
              </ScrollArea>
            )}
          </ResizablePanel>

          <ResizableHandle withHandle />

          <ResizablePanel defaultSize={40} minSize={25}>
            {isEditingMarkdown ? (
              <div className="h-full flex flex-col">
                <div className="flex items-center gap-2 px-4 py-2 border-b border-border">
                  <Button
                    size="sm"
                    onClick={handleMarkdownSave}
                    disabled={!markdownChanges.hasChanges || isSavingMarkdown}
                    className="h-7 px-2 text-xs"
                  >
                    Save
                  </Button>
                  <Button
                    size="sm"
                    onClick={handleMarkdownCancel}
                    variant="outline"
                    disabled={isSavingMarkdown}
                    className="h-7 px-2 text-xs"
                  >
                    Cancel
                  </Button>
                </div>
                <Textarea
                  value={editingMarkdown}
                  onChange={(e) => handleMarkdownChange(e.target.value)}
                  className="flex-1 font-mono text-xs rounded-none border-0 resize-none"
                  placeholder="Enter markdown content..."
                  spellCheck="false"
                />
              </div>
            ) : (
              <ScrollArea className="h-full">
                <div
                  className="p-6 prose prose-sm max-w-none dark:prose-invert text-foreground prose-headings:mt-4 prose-headings:mb-2 prose-p:mb-2 prose-li:ml-4 cursor-text hover:bg-muted/30 transition-colors"
                  onDoubleClick={handleMarkdownEdit}
                  title="Double-click to edit"
                >
                  {/* @ts-ignore */}
                  <ReactMarkdown
                    remarkPlugins={[remarkGfm]}
                    components={{
                      h1: ({node, ...props}) => <h1 className="text-lg font-bold mb-3 mt-4" {...props} />,
                      h2: ({node, ...props}) => <h2 className="text-base font-semibold mb-2 mt-3" {...props} />,
                      h3: ({node, ...props}) => <h3 className="text-sm font-semibold mb-2 mt-2" {...props} />,
                      p: ({node, ...props}) => <p className="mb-2 text-sm" {...props} />,
                      li: ({node, ...props}) => <li className="ml-4 mb-1 text-sm" {...props} />,
                      ul: ({node, ...props}) => <ul className="list-disc ml-4" {...props} />,
                      ol: ({node, ...props}) => <ol className="list-decimal ml-4" {...props} />,
                      table: ({node, ...props}) => <table className="border-collapse border border-border text-xs" {...props} />,
                      thead: ({node, ...props}) => <thead className="bg-muted/50" {...props} />,
                      th: ({node, ...props}) => <th className="border border-border px-2 py-1 text-xs font-semibold text-left" {...props} />,
                      td: ({node, ...props}) => <td className="border border-border px-2 py-1 text-xs" {...props} />,
                      tr: ({node, ...props}) => <tr className="hover:bg-muted/20" {...props} />,
                      code: ({node, ...props}: any) => {
                        const isInline = !props.children?.toString().includes('\n');
                        return isInline ? (
                          <code className="bg-muted px-1.5 py-0.5 rounded text-xs font-mono" {...props} />
                        ) : (
                          <code className="block bg-muted p-2 rounded text-xs font-mono overflow-x-auto" {...props} />
                        );
                      },
                    }}
                  >
                    {currentData.conclusion || ''}
                  </ReactMarkdown>
                </div>
              </ScrollArea>
            )}
          </ResizablePanel>
        </ResizablePanelGroup>
      ) : currentData.type === 'chart' && currentNodeViewMode === 'table' ? (
        <div className="w-full flex-1 flex items-center justify-center p-4 bg-muted/10">
          {currentData.result_format === 'image' || currentData.result_format === 'visualization' ? (
            <img
              src={getFileUrl(projectId, displayedNodeId || '', currentData.result_format)}
              alt={`${displayedNodeId} visualization`}
              style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }}
              onError={(e) => {
                console.error(`Failed to load image for node ${displayedNodeId}:`, e);
                (e.target as HTMLImageElement).src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="200" height="200"%3E%3Crect width="200" height="200" fill="%23f0f0f0"/%3E%3Ctext x="50%25" y="50%25" dominant-baseline="middle" text-anchor="middle" font-size="14" fill="%23999"%3EImage not found%3C/text%3E%3C/svg%3E';
              }}
            />
          ) : (
            renderChart(currentData.chartType, currentData.data)
          )}
        </div>
      ) : currentData.type === 'chart' && currentNodeViewMode === 'code' ? (
        isEditingCode ? (
          <div className="flex-1 flex flex-col">
            <div className="flex items-center gap-2 px-4 py-2 border-b border-border">
              <Button
                size="sm"
                onClick={handleCodeSave}
                disabled={!codeChanges.hasChanges || isSavingCode}
                className="h-7 px-2 text-xs"
              >
                Save
              </Button>
              <Button
                size="sm"
                onClick={handleCodeCancel}
                variant="outline"
                disabled={isSavingCode}
                className="h-7 px-2 text-xs"
              >
                Cancel
              </Button>
              <div className="flex-1" />
              <Button
                size="sm"
                onClick={handleExecuteNode}
                disabled={isExecuting}
                className="h-7 px-3 text-xs bg-green-600 hover:bg-green-700"
              >
                {isExecuting ? (
                  <>
                    <Loader2 className="h-3 w-3 mr-1 animate-spin" />
                    Executing...
                  </>
                ) : (
                  <>
                    <Play className="h-3 w-3 mr-1" />
                    Execute
                  </>
                )}
              </Button>
            </div>
            <CodeEditor value={editingCode} onChange={handleCodeChange} />
          </div>
        ) : (
          <ScrollArea className="flex-1">
            <div
              className="p-4 cursor-text hover:bg-muted/10 transition-colors"
              onDoubleClick={handleCodeEdit}
              title="Double-click to edit"
            >
              {/* @ts-ignore */}
              <SyntaxHighlighter
                language="python"
                style={atomOneDark}
                className="text-sm"
                customStyle={{
                  margin: 0,
                  padding: 0,
                  backgroundColor: 'transparent',
                }}
              >
                {currentData.codeWithMetadata || currentData.code}
              </SyntaxHighlighter>
            </div>
          </ScrollArea>
        )
      ) : (
        currentNodeViewMode === 'table' ? (
          <div className="overflow-x-auto flex-1">
            <Table>
              <TableHeader>
                <TableRow className="bg-table-header hover:bg-table-header">
                  {currentData.headers.map((header, index) => (
                    <TableHead key={index} className="font-semibold whitespace-nowrap">
                      {header}
                    </TableHead>
                  ))}
                </TableRow>
              </TableHeader>
              <TableBody>
                {currentData.data.map((row, rowIndex) => (
                  <TableRow
                    key={rowIndex}
                    className="hover:bg-table-hover transition-colors"
                  >
                    {currentData.headers.map((header, colIndex) => (
                      <TableCell
                        key={colIndex}
                        className={colIndex === 0 ? "font-medium whitespace-nowrap" : "whitespace-nowrap"}
                      >
                        {row[header]}
                      </TableCell>
                    ))}
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </div>
        ) : isEditingCode ? (
          <div className="flex-1 flex flex-col">
            <div className="flex items-center gap-2 px-4 py-2 border-b border-border">
              <Button
                size="sm"
                onClick={handleCodeSave}
                disabled={!codeChanges.hasChanges || isSavingCode}
                className="h-7 px-2 text-xs"
              >
                Save
              </Button>
              <Button
                size="sm"
                onClick={handleCodeCancel}
                variant="outline"
                disabled={isSavingCode}
                className="h-7 px-2 text-xs"
              >
                Cancel
              </Button>
              <div className="flex-1" />
              <Button
                size="sm"
                onClick={handleExecuteNode}
                disabled={isExecuting}
                className="h-7 px-3 text-xs bg-green-600 hover:bg-green-700"
              >
                {isExecuting ? (
                  <>
                    <Loader2 className="h-3 w-3 mr-1 animate-spin" />
                    Executing...
                  </>
                ) : (
                  <>
                    <Play className="h-3 w-3 mr-1" />
                    Execute
                  </>
                )}
              </Button>
            </div>
            <CodeEditor value={editingCode} onChange={handleCodeChange} />
          </div>
        ) : (
          <ScrollArea className="flex-1">
            <div
              className="p-4 cursor-text hover:bg-muted/10 transition-colors"
              onDoubleClick={handleCodeEdit}
              title="Double-click to edit"
            >
              {/* @ts-ignore */}
              <SyntaxHighlighter
                language="python"
                style={atomOneDark}
                className="text-sm"
                customStyle={{
                  margin: 0,
                  padding: 0,
                  backgroundColor: 'transparent',
                }}
              >
                {currentData.codeWithMetadata || currentData.code}
              </SyntaxHighlighter>
            </div>
          </ScrollArea>
        )
      )}

      {currentData.totalRecords > 10 && currentNodeViewMode !== 'code' && currentData.type !== 'chart' && displayedNodeId && (
        <div className="flex items-center justify-between px-4 py-3 border-t border-border">
          <div className="text-sm text-muted-foreground">
            共 <span className="font-medium text-foreground">{currentData.totalRecords.toLocaleString()}</span> 条
          </div>
          <div className="flex items-center gap-1">
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={() => handlePageChange(currentPage - 1)}
              disabled={currentPage === 1}
            >
              <ChevronLeft className="h-4 w-4" />
            </Button>
            {getPageNumbers().map((page, index) =>
              page === '...' ? (
                <div key={`ellipsis-${index}`} className="h-8 w-8 flex items-center justify-center text-xs text-muted-foreground">
                  ...
                </div>
              ) : (
                <Button
                  key={page}
                  variant="ghost"
                  size="sm"
                  className={`h-8 min-w-8 ${
                    currentPage === page
                      ? 'bg-primary text-primary-foreground hover:bg-primary/90'
                      : 'hover:bg-muted'
                  }`}
                  onClick={() => handlePageChange(page as number)}
                >
                  {page}
                </Button>
              )
            )}
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8"
              onClick={() => handlePageChange(currentPage + 1)}
              disabled={currentPage === totalPages}
            >
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}

      {/* Unsaved Changes Dialogs */}
      <UnsavedChangesDialog
        open={markdownChanges.showDialog}
        isSaving={isSavingMarkdown}
        onSave={() => markdownChanges.confirmSave(() => handleMarkdownSave())}
        onDiscard={markdownChanges.confirmDiscard}
        onCancel={markdownChanges.confirmCancel}
        title="Unsaved Markdown Changes"
        description="You have unsaved changes in the markdown editor. What would you like to do?"
      />
      <UnsavedChangesDialog
        open={codeChanges.showDialog}
        isSaving={isSavingCode}
        onSave={() => codeChanges.confirmSave(() => handleCodeSave())}
        onDiscard={codeChanges.confirmDiscard}
        onCancel={codeChanges.confirmCancel}
        title="Unsaved Code Changes"
        description="You have unsaved changes in the code editor. What would you like to do?"
      />
    </div>
  );
}
